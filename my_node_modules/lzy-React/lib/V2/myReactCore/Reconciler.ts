import { FiberNode } from './Interface'
import { global } from './GlobalFiber'


// 判断是否为空值
export function isEmpty(value: any) {
    return typeof value === 'undefined' || value === null
}

//! 更新事件
// TODO (重要)如果节点有挂载事件  需要更新这些事件(否则无法更新  事件引用不会变更)!!!!!!!!!
function reconcileEvent(workInProgressFiber: FiberNode, currentFiber: FiberNode) {

    const wkProps = workInProgressFiber?._element?.props
    if (!wkProps) return
    // 如果有事件 创建对应的Effect
    const hasEvent = wkProps.hasOwnProperty('onClick' || 'onMouseOver')
    if (hasEvent) {
        pushEffectList('Update', workInProgressFiber)
    }
}

//! 判断是否有useEffect钩子调用
function reconcileUseEffect(workInProgressFiber: FiberNode, currentFiber: FiberNode) {
    if (workInProgressFiber?.updateQueue?.lastEffect) {
        pushEffectList('UseEffect', workInProgressFiber)
    }
}

//! 计算Text
function reconcileText(workInProgressFiber: FiberNode, currentFiber: FiberNode) {
    if (!workInProgressFiber || !currentFiber) return
    if (isEmpty(workInProgressFiber.text) || isEmpty(currentFiber.text)) return
    if (workInProgressFiber.text !== currentFiber.text) {
        pushEffectList('Update', workInProgressFiber)
    }
}

//! 计算tag
function reconcileTag(workInProgressFiber: FiberNode, currentFiber: FiberNode) {

}

//! 添加
function reconcilePlacement(workInProgressFiber: FiberNode, currentFiber: FiberNode) {

    if (workInProgressFiber.effectTag === 'Placement') {
        pushEffectList('Placement', workInProgressFiber)
    }
    // 或者有cur  无work算为插入节点(首屏渲染)
    if (!currentFiber && workInProgressFiber) {
        pushEffectList('Placement', workInProgressFiber)
    }

}

//! 删除
function reconcileDeletion(workInProgressFiber: FiberNode, currentFiber: FiberNode) {


    //todo wk没有节点 current有节点 删除current
    if (!workInProgressFiber && currentFiber) {
        pushEffectList('Delete', currentFiber)
        return false
    }

    //todo 如果有key  且不一样 删除current 否则下一次会进行大量更新(需要重写)
    else if (workInProgressFiber.key || currentFiber.key) {
        if (workInProgressFiber.key !== currentFiber.key) {
            pushEffectList('Delete', currentFiber)
            return false
        }
    }

    return true
}

//! 创建并添加Effect到EffectList
export function pushEffectList(tag: string, targetFiber: FiberNode, callback?: Function) {
    const newEffect = {
        tag, // Effect的类型
        targetFiber, // 需要执行的fiber节点
        callback: '暂定',
        next: null
    }
    //todo 链接到全局EffectList单链表
    const EffectList = global.EffectList

    if (EffectList.firstEffect === null) {
        EffectList.firstEffect = newEffect
        EffectList.lastEffect = newEffect
    } else {
        EffectList.lastEffect.next = newEffect
        EffectList.lastEffect = newEffect
    }
    EffectList.length += 1
}


//! diff两个节点综合方法
//! ----------比较wk和cur两个fiber  生成不同的Effect (打上tag)-------------
function reconcileFiberNode(workInProgressFiber: FiberNode, currentFiber: FiberNode) {

    //TODO 开始先进行删除和添加的diff计算  (需要在最先进行 因为之后的就不需要进行了)
    reconcilePlacement(workInProgressFiber, currentFiber)

    let needDiff = true

    if (workInProgressFiber && !currentFiber) {
        needDiff = false
    } else if (!workInProgressFiber && currentFiber) {
        reconcileDeletion(workInProgressFiber, currentFiber)
        needDiff = false
    }

    if (needDiff) {
        // TODO 进行text的判断 生成Effect
        reconcileText(workInProgressFiber, currentFiber)
        //TODO 有事件更新事件
        reconcileEvent(workInProgressFiber, currentFiber)
    }

}


//! diff两个Element的方法
// function reconcileElement(new, old) {

// }


export { reconcileFiberNode, reconcileUseEffect }