// 切片while测试(需运行在浏览器环境)
function concurrentWhile(getCondition, handler, yieldInterval) {
    // 判断环境
    if (typeof window === 'undefined') {
        throw new Error('请在浏览器环境下使用')
    }
    if (!MessageChannel) {
        throw new Error('本工具仅兼容所有人类使用的浏览器(请不要使用IE谢谢)')
    }


    let getCurrentTime = () => performance.now();
    let deadLine = 0                       // 本帧react应该停止的时间
    let isMessageChannelRunnig = false     // 本帧react的任务是否在执行
    let scheduledHostCallBack = null       // 已经计算过的用户事件(workLoop)
    let shouldYieldToHost = () => getCurrentTime() >= deadLine   // 超过deadLine时让出JS主线程给用户
    let channel = new MessageChannel()     // 建立通信 port用来发布任务
    let port = channel.port2               // 当port1收到消息时会执行react渲染短任务


    // 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
    const requestHostCallback = (cb) => {
        scheduledHostCallBack = cb
        if (!isMessageChannelRunnig) {
            isMessageChannelRunnig = true
            port.postMessage(null)
        }
    }

    // 执行单次切片的逻辑
    const performWorkUntilDeadline = () => {
        console.log(`-----${yieldInterval}ms切片-----`);
        // 如果没有用户任务  状态直接改为false
        if (!scheduledHostCallBack) {
            isMessageChannelRunnig = false
        }
        // 如果有用户任务
        if (scheduledHostCallBack !== null) {
            let currentTime = getCurrentTime()
            deadLine = currentTime + yieldInterval // 停止react任务的时间
            const shouldContinue = true

            try {
                const hasMoreWork = scheduledHostCallBack(shouldContinue, currentTime) // 执行workLoop
                // 如果执行完毕  初始化工作环境
                if (!hasMoreWork) {
                    isMessageChannelRunnig = false
                    scheduledHostCallBack = null
                }
                // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
                if (hasMoreWork) {
                    port.postMessage(null)
                }
            } catch (error) {
                port.postMessage(null);
                throw error;
            }
        }
    }

    // 初始化工作环境
    yieldInterval = yieldInterval || 5 // 每一帧留给react的工作时间
    channel.port1.onmessage = performWorkUntilDeadline


    // 创建whild循环体
    let workLoop = () => {
        while (!shouldYieldToHost() && getCondition()) {
            handler()
        }
        return getCondition()
    }

    requestHostCallback(workLoop);
}

function test() {
    let a = 0
    const getCondition = () => a < 10000
    concurrentWhile(getCondition, () => {
        console.log('执行');
        a++
    })
}
