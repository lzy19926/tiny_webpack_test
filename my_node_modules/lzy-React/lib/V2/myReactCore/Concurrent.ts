
// 本文件提供了时间切片和concurrent模式的方法实现
//! react会定义每一帧的工作时间 默认5s (每16.6ms会执行5ms的React任务,剩下的时间交给浏览器,防止卡顿)
//! shouldYieldToHost在外部执行workLoop时(render时)  判断是否让出主线程

let getCurrentTime = () => performance.now();
let yieldInterval = 5 // 每一帧留给react的工作时间
let deadLine = 0 // 本帧react应该停止的时间
let isMessageChannelRunnig = false // 本帧react的任务是否在执行
let scheduledHostCallBack = null // 已经计算过的用户事件(workLoop)
export const shouldYieldToHost = () => getCurrentTime() >= deadLine // 超过deadLine时让出主线程
// 建立通信
// port用来发布任务
// 当port1收到消息时会执行react渲染短任务
const channel = new MessageChannel()
const port = channel.port2
channel.port1.onmessage = performWorkUntilDeadline

// 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
export function requestHostCallback(cb) {
    scheduledHostCallBack = cb
    if (!isMessageChannelRunnig) {
        isMessageChannelRunnig = true
        port.postMessage(null)
    }
}

// 执行每5ms的高频工作
export function performWorkUntilDeadline() {
    console.log('单个5ms的任务');

    // 如果没有用户任务  状态直接改为false
    if (!scheduledHostCallBack) {
        isMessageChannelRunnig = false
    }
    // 如果有用户任务
    if (scheduledHostCallBack !== null) {
        let currentTime = getCurrentTime()
        deadLine = currentTime + yieldInterval // 停止react任务的时间
        const shouldContinue = true

        try {
            const hasMoreWork = scheduledHostCallBack(shouldContinue, currentTime) // 执行workLoop

            // 如果执行完毕  初始化工作环境
            if (!hasMoreWork) {
                isMessageChannelRunnig = false
                scheduledHostCallBack = null
            }
            // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
            if (hasMoreWork) {
                port.postMessage(null)
            }
        } catch (error) {
            port.postMessage(null);
            throw error;
        }


    }
}







// ----------使用方法----------
// 放入requestHostCallBack中的基本单元  可以将其中的逻辑进行拆分
// function workLoop(shouldContinue, initialTime) {
//     while (!shouldYieldToHost() && workIndex < taskTotal) {
//         handleWork();
//     }

//     // 如果未完成工作  则开启下一个宏任务继续执行
//     if (workIndex < taskTotal) {
//         console.log(`每帧执行的5ms长任务片段`);
//         return true
//     }
//     else {
//         return false
//     }
// }

// requestHostCallback(workLoop);