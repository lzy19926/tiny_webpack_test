// 本文件提供了时间切片和concurrent模式的方法实现
//! react会定义每一帧的工作时间 默认5s (每16.6ms会执行5ms的React任务,剩下的时间交给浏览器,防止卡顿)
//! shouldYieldToHost在外部执行workLoop时(render时)  判断是否让出主线程

let currentTime: number = 0// 从页面加载开始计算的当前时间
let getCurrentTime = () => performance.now()
let yieldInterval: number = 5 // 每一帧留给react的工作时间
let deadLine: number = 0 // 本帧react应该停止的时间
let isMessageChannelRunnig = false // 本帧react的任务是否在执行
let shouldYieldToHost = () => currentTime >= deadLine // 超过deadLine时让出主线程
let scheduledHostCallBack = null // 已经计算过的用户事件(workLoop)



//! 将用户事件插入每一帧的剩余时间里
function conCurrent(hostCallback: Function) {

    //! 非浏览器环境或不支持MessageChannel的环境下使用setTimeout来实现
    if (typeof window === 'undefined' || typeof MessageChannel !== 'function') return


    currentTime = getCurrentTime()

    const channel

}

// 执行每5ms的高频工作
function performWorkUntilDeadline() {

    // 如果没有用户任务  状态直接改为false
    if (!scheduledHostCallBack) {
        isMessageChannelRunnig = false
    }
    // 如果有用户任务
    if (scheduledHostCallBack !== null) {
        currentTime = getCurrentTime()
        deadLine = currentTime + yieldInterval // 停止react任务的时间
        const shouldContinue = true
        try {
            const hasMoreWork = scheduledHostCallBack(shouldContinue, currentTime) // 执行workLoop

            // 如果执行完毕  初始化工作环境
            if (!hasMoreWork) {
                isMessageChannelRunnig = false
                scheduledHostCallBack = null
            }
            // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
            if (hasMoreWork) {
                port.postMessage(null)
            }
        }


    }
}

// 建立通信
// port用来发布任务
// 当port1收到消息时会执行react渲染短任务
const channel = new MessageChannel()
const port = channel.port2
channel.port1.onmessage = performWorkUntilDeadline

// 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
function requestHostCallBack(cb: Function) {
    scheduledHostCallBack = cb
    if (!isMessageChannelRunnig) {
        isMessageChannelRunnig = true
        port.postMessage(null)
    }
}


// 放入requestHostCallBack中的基本单元  可以将其中的逻辑进行拆分
function workLoop(shouldContinue: boolean, initialTime: number) {
    while (!shouldYieldToHost() && isWorkDone()) {
        //todo 执行内部代码
    }

    // 如果未完成工作  则开启下一个宏任务继续执行
    if (!isWorkDone()) return true
    else return false
}

export { conCurrent }

