
import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode, TextElementNode } from '../myReactCore/Interface'
import { transformElementTreeToBinadyTree } from '../myJSX/createElement'
import { concurrentWhile, concurrentWhileHook } from '../concurrent/concurrent'
import { createFiber, createAlternate_concurrent, createFiberTree, createAlternate } from './createFiberTree'

//! ---------------更新fiberTree 遍历wk树-------------------
//   (不需要更新跟组件节点的sibling节点  下层需要更新)
export function updateFiberTree(
    newElementNode: ElementNode | TextElementNode,
    workInProgressFiber: FiberNode,
    tag?: string) {

    //todo 删除节点逻辑
    if (!newElementNode) {
        console.log('无此节点', newElementNode, workInProgressFiber);
    }

    // 链接element和节点
    workInProgressFiber._element = newElementNode
    newElementNode.fiber = workInProgressFiber

    // 切换当前工作fiber
    global.workInprogressFiberNode = workInProgressFiber

    //如果tag大写 解析为FC组件节点 
    if (newElementNode.tag[0] === newElementNode.tag[0].toUpperCase()) {
        workInProgressFiber.nodeType = 'FunctionComponent'
        workInProgressFiber.stateNode = newElementNode.ref
        //! 挂载props(这里从alternate中获取  需要修改)
        const props = newElementNode.props
        const childElementTree = newElementNode.ref.call(undefined, props)
        newElementNode._child = transformElementTreeToBinadyTree(childElementTree, newElementNode)  //! 重新生成新的二叉element树 并链接 
    }
    //解析为text节点 挂载dom节点
    else if (newElementNode.tag === 'text') {
        workInProgressFiber.nodeType = 'HostText'
        workInProgressFiber.text = newElementNode.text
        workInProgressFiber.stateNode = newElementNode.ref
    }
    //解析为普通dom节点
    else {
        workInProgressFiber.nodeType = 'HostComponent'
        workInProgressFiber.stateNode = newElementNode.ref
    }

    //深度优先递归执行
    if (newElementNode._child) {
        const childWkFiber = updateFiberTree(newElementNode._child, workInProgressFiber._child)
        workInProgressFiber._child = childWkFiber
    }
    if (newElementNode._sibling && tag !== 'rootUpdateFiber') {// (不需要更新跟组件节点的sibling节点)
        const siblingWkFiber = updateFiberTree(newElementNode._sibling, workInProgressFiber._sibling)
        workInProgressFiber._sibling = siblingWkFiber
    }

    return workInProgressFiber
}

//! updateFiberTree中将遍历fiber树的while循环放入workloop中进行切片
//! 然后通过钩子系统,在结束切片任务后  执行commit的逻辑
export function updateFiberTree_concurrent(
    newElementNode: ElementNode | TextElementNode,
    workInProgressFiber: FiberNode,
    currentFiber: FiberNode,
    tag?: string
) {



    // 首先处理跟节点  不遍历根节点的sibling

    //todo------- 遍历二叉element树----

    const stack = []
    let prevFiber;
    let rootFiber: FiberNode = workInProgressFiber;

    stack.push({ newElementNode, workInProgressFiber, currentFiber, tag })

    // 将 render的while循环遍历fiberTree的逻辑切片执行
    const getCondition = () => stack.length > 0

    concurrentWhile(getCondition, () => {

        let { newElementNode, workInProgressFiber, currentFiber, tag } = stack.pop()

        console.log(newElementNode, workInProgressFiber);

        // 添加节点
        if (newElementNode && !workInProgressFiber) {
            const parentFiber = newElementNode._parent.fiber
            const newFiber = createFiberTree(newElementNode, parentFiber)
            const newAltFiber = createAlternate(newFiber)

            parentFiber._child = newFiber
            parentFiber.alternate._child = newAltFiber
            newFiber.effectTag = 'Placement'
            newAltFiber.effectTag = 'Placement'

            workInProgressFiber = newFiber
            currentFiber = newAltFiber
            console.log('添加节点', newFiber);
        }




        workInProgressFiber = updateFiber(newElementNode, workInProgressFiber, currentFiber)
        // 保存上一个节点
        prevFiber = workInProgressFiber


        // 将下一个节点入栈 继续遍历 (注意这里childElement的声明要放在后面,否则可能会保存为undefined)
        let childElement = newElementNode._child
        let siblingElement = newElementNode._sibling

        if (siblingElement && tag !== 'rootUpdateFiber') {// (不需要更新跟组件节点的sibling节点)) {
            console.log('推入sibling');
            stack.push({
                newElementNode: siblingElement,
                workInProgressFiber: workInProgressFiber._sibling,// 从sibling进入
                currentFiber: workInProgressFiber.alternate._sibling,
                tag: ''
            })
        }

        if (childElement) {

            stack.push({
                newElementNode: childElement,
                workInProgressFiber: workInProgressFiber._child,
                currentFiber: workInProgressFiber.alternate._child,
                tag: ''
            })
        }



        //! 通过钩子系统,在结束切片任务后  执行commit的逻辑
        if (!getCondition()) {
            console.log('切片updateRender完毕,执行后续操作');
            concurrentWhileHook.afterUpdateRender()
        }

    })
    return rootFiber
}


// 更新单个workInFiber
function updateFiber(
    newElementNode: ElementNode | TextElementNode,
    workInProgressFiber: FiberNode,
    currentFiber: FiberNode) {

    // 链接element和节点
    workInProgressFiber.tag = newElementNode.tag
    workInProgressFiber._element = newElementNode
    newElementNode.fiber = workInProgressFiber

    // 切换当前工作fiber
    global.workInprogressFiberNode = workInProgressFiber

    //如果tag大写 解析为FC组件节点
    if (newElementNode.tag[0] === newElementNode.tag[0].toUpperCase()) {
        workInProgressFiber.nodeType = 'FunctionComponent'
        workInProgressFiber.stateNode = newElementNode.ref
        //! 挂载props(这里从alternate中获取  需要修改)
        const props = currentFiber._element.props
        const childElementTree = newElementNode.ref.call(undefined, props)
        newElementNode._child = transformElementTreeToBinadyTree(childElementTree, newElementNode)  //! 重新生成新的二叉element树 并链接 
    }
    //解析为text节点 挂载dom节点
    else if (newElementNode.tag === 'text') {
        workInProgressFiber.nodeType = 'HostText'
        workInProgressFiber.text = newElementNode.text
        workInProgressFiber.stateNode = currentFiber.stateNode
    }
    //解析为普通dom节点
    else {
        workInProgressFiber.nodeType = 'HostComponent'
        workInProgressFiber.stateNode = currentFiber.stateNode
    }

    return workInProgressFiber
}

//! 创建Placement的fiberNode  类似createFiberTree
function placementFiberTree(source: any, resources: any, parentNode: FiberNode) {

    //todo 创建一个新的fiber节点(浅拷贝) 更新当前工作节点
    let newFiberNode = new NewFiberNode('mount', parentNode.$fiber)
    //todo 预处理Fiber  生成vnode 挂载resource
    const { children, tag } = preHandleFiberNode(source, resources, newFiberNode)
    //todo 挂载父节点
    newFiberNode.parentNode = parentNode
    //TODO -----------如果tag大写 解析为组件节点(无children) ----------------
    if (tag[0] === tag[0].toUpperCase()) {
        //! 处理为组件节点   并继续向下递归render子函数组件
        handleFunctionFiberNode(newFiberNode, tag)

        placementFunctionComponent(newFiberNode)
    }

    //TODO ----------小写的情况  是dom节点 创建Effect 交给commit阶段执行添加--------
    else {
        newFiberNode.nodeType = 'HostText'
    }

    //todo 继续向下深度优先递归  创建子fiber 挂到当前节点
    placementFiberTreeLoop(children, newFiberNode)

    newFiberNode.fiberFlags = 'update'

    //适配路由
    useRoute(newFiberNode)
    //todo 在这里创建一个effect!

    return newFiberNode
}

//! 根据子vnode 递归创建创建Placement的fiberNode 并进行拼接-------------
function placementFiberTreeLoop(childVnodes: any, parentNode: FiberNode) {
    if (childVnodes.length > 0) {
        parentNode.nodeType = 'HostComponent'
        for (let i = 0; i < childVnodes.length; i++) {
            const childFiberNode = placementFiberTree(childVnodes[i], parentNode.sourcePool, parentNode)
            parentNode.children.push(childFiberNode)
        }
    }
}

//! 添加函数组件节点
function placementFunctionComponent(fiber: FiberNode) {

    if (typeof fiber.stateNode !== 'function') return

    const { template, data = {}, components = {} } = fiber.stateNode()

    const childFiberNode = placementFiberTree(template, { data, components }, fiber)
    //todo 生成子树并链接
    fiber.children = [childFiberNode]

}