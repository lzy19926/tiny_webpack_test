import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode, TextElementNode } from "../myReactCore/Interface";
import { transformElementTreeToBinadyTree } from '../myJSX/createElement'





let requestHostCallback; // 处理 taskQueue 任务
let cancelHostCallback;
let requestHostTimeout; // 处理 timerQueue 任务
let cancelHostTimeout;
let shouldYieldToHost; // 是否让出主线程（currentTime >= deadline）
let getCurrentTime; // 获取当前时间
let forceFrameRate; // 根据 FPS 计算每一帧时长


if (typeof window === 'undefined' || typeof MessageChannel !== 'function') {
    // 非浏览器环境，或不支持 MessageChannel，会使用 setTimeout 宏任务来实现
} else {
    // 保存 api 引用，防止 polyfill 覆盖它们
    const setTimeout = window.setTimeout;
    const clearTimeout = window.clearTimeout;

    getCurrentTime = () => performance.now(); // 页面加载后开始计算

    let isMessageLoopRunning = false; // 标记 MessageChannel 正在运行
    let scheduledHostCallback = null; // 要执行的处理函数
    let taskTimeoutID = -1; // 用作终止 setTimeout 延迟任务

    // 定义每一帧工作时间，默认时间为 5ms，React 会根据浏览器主机环境进行重新计算。
    let yieldInterval = 5;
    let deadline = 0; // 过期时间，让出主线程

    // 让出主线程
    shouldYieldToHost = function () {
        return getCurrentTime() >= deadline;
    };

    // 默认空闲执行时间是5ms，用户可通过该方法来根据不同用户主机的设备刷新率（FPS）来计算预留时间
    forceFrameRate = function (fps) {
        if (fps < 0 || fps > 125) {
            return;
        }
        if (fps > 0) {
            yieldInterval = Math.floor(1000 / fps);
        } else {
            yieldInterval = 5;
        }
    };

    // 开启高频短间隔 5ms 执行工作
    const performWorkUntilDeadline = () => {
        if (scheduledHostCallback !== null) {
            const currentTime = getCurrentTime(); // 拿到当前时间
            // 根据 yieldInterval（5ms）计算剩余时间（任务执行截止时间）。这种方式意味着 port.postMessage 开始后总有剩余时间
            deadline = currentTime + yieldInterval;
            // 标识还有时间，类似 requestIdleCallback deadline.didTimeout
            const hasTimeRemaining = true;
            try {
                const hasMoreWork = scheduledHostCallback(
                    hasTimeRemaining,
                    currentTime,
                );
                // 执行完成，没有新任务，初始化工作环境
                if (!hasMoreWork) {
                    isMessageLoopRunning = false;
                    scheduledHostCallback = null;
                } else {
                    // 如果任务截止时间过期（根据 shouldYieldToHost()），还有需要处理的工作，再发起一个异步宏任务
                    port.postMessage(null);
                }
            } catch (error) {
                port.postMessage(null);
                throw error;
            }
        } else {
            isMessageLoopRunning = false;
        }
    };


    // 定义宏任务，建立通信
    const channel = new MessageChannel();
    const port = channel.port2; // 用于发布任务
    channel.port1.onmessage = performWorkUntilDeadline; // 处理任务

    requestHostCallback = function (callback) {
        scheduledHostCallback = callback; // 保存任务
        if (!isMessageLoopRunning) {
            isMessageLoopRunning = true;
            port.postMessage(null); // 发起宏任务
        }
    };

    cancelHostCallback = function () {
        scheduledHostCallback = null;
    };

    requestHostTimeout = function (callback, ms) {
        taskTimeoutID = setTimeout(() => {
            callback(getCurrentTime());
        }, ms);
    };

    cancelHostTimeout = function () {
        clearTimeout(taskTimeoutID);
        taskTimeoutID = -1;
    };
}




//! ------------初始创建fiberTree-------------------
export function createFiberTree(rootElement: ElementNode | TextElementNode) {
    let start = Date.now()
    //todo------- 遍历二叉element树----
    const stack = []
    let prevFiber;
    let currentFiber;
    let rootFiber: FiberNode;

    // 创建App节点
    rootFiber = currentFiber = createRootFiber(rootElement)

    // 从App的child开始遍历
    if (rootElement._child) stack.push({
        elementNode: rootElement._child,
        from: 'child',
        parentFiber: rootFiber
    })

    prevFiber = rootFiber


    // workLoop的whild循环中放入 render的while循环逻辑
    //! 将while循环(或者for)切片
    const workLoop = (shouldContinue, initialTime) => {
        while (!shouldYieldToHost() && stack.length) {
            let { from, elementNode, parentFiber } = stack.pop()
            currentFiber = createFiber(elementNode, parentFiber)
            if (from === 'child') { prevFiber._child = currentFiber }
            else if (from === 'sibling') { prevFiber._sibling = currentFiber }
            let childElement = elementNode._child
            let siblingElement = elementNode._sibling

            if (siblingElement) {
                prevFiber = currentFiber
                stack.push({ elementNode: siblingElement, from: 'sibling', parentFiber: parentFiber })
            }
            if (childElement) {
                prevFiber = currentFiber
                stack.push({ elementNode: childElement, from: 'child', parentFiber: currentFiber })
            }

            if (!stack.length) {
                console.log(`首屏渲染render阶段完成，用时:`, Date.now() - start, 'ms!');
                global.isFirstRenderDone = true
            }
        }
        if (stack.length) {
            console.log(`切片渲染,开启下一个切片`);
            return true;
        } else {
            return false;
        }
    }

    requestHostCallback(workLoop);






    return rootFiber
}



//! ------------初始创建fiberTree-------------------
export function createFiberTree3(rootElement: ElementNode | TextElementNode) {
    let start = Date.now()
    //todo------- 遍历二叉element树----
    const stack = []
    let prevFiber;
    let currentFiber;
    let rootFiber: FiberNode;

    // 创建App节点
    rootFiber = currentFiber = createRootFiber(rootElement)

    // 从App的child开始遍历
    if (rootElement._child) stack.push({
        elementNode: rootElement._child,
        from: 'child',
        parentFiber: rootFiber
    })

    prevFiber = rootFiber

    //todo--- 遍历根节点下的fiber------
    while (stack.length) {
        // 根据element创建一个fiber
        //  stack.pop()为此时遍历到的element   执行处理逻辑
        let { from, elementNode, parentFiber } = stack.pop()
        currentFiber = createFiber(elementNode, parentFiber)

        // 链接前后fiber
        if (from === 'child') { prevFiber._child = currentFiber }
        else if (from === 'sibling') { prevFiber._sibling = currentFiber }

        // 将下一个节点入栈 继续遍历 (注意这里childElement的声明要放在后面,否则可能会保存为undefined)
        let childElement = elementNode._child
        let siblingElement = elementNode._sibling

        if (siblingElement) {
            prevFiber = currentFiber
            stack.push({ elementNode: siblingElement, from: 'sibling', parentFiber: parentFiber })
        }
        if (childElement) {
            prevFiber = currentFiber
            stack.push({ elementNode: childElement, from: 'child', parentFiber: currentFiber })
        }
    }

    if (!stack.length) {
        console.log(`首屏渲染render阶段完成，用时:`, Date.now() - start, 'ms!');
        global.isFirstRenderDone = true
    }

    return rootFiber
}

//!------ 单独处理创建AppFiber节点
function createRootFiber(rootElement: ElementNode | TextElementNode) {
    // 首先创建rootFiber(单独处理app节点) 
    const childElementTree = rootElement.ref.call(undefined, rootElement.props)    //! 挂载props
    rootElement._child = transformElementTreeToBinadyTree(childElementTree, rootElement) //! 重新生成新的二叉element树

    let rootFiber = new FiberNode('mount', '$1')
    global.workInprogressFiberNode = rootFiber  //todo 切换当前工作fiber

    rootFiber.tag = rootElement.tag
    rootFiber._element = rootElement
    rootElement.fiber = rootFiber
    rootFiber.nodeType = 'AppNode'
    rootFiber.stateNode = rootElement.ref
    rootFiber.fiberFlags = 'update'

    return rootFiber
}

//!------ 创建fiber节点
function createFiber(elementNode: ElementNode | TextElementNode, parentFiber: FiberNode) {
    // 创建newFiber
    let newFiberNode = new FiberNode('mount', '$1')

    // 切换当前工作fiber
    global.workInprogressFiberNode = newFiberNode

    // 给fiber赋值 并链接parent
    newFiberNode._parent = parentFiber
    newFiberNode.tag = elementNode.tag
    newFiberNode._element = elementNode
    elementNode.fiber = newFiberNode

    //如果tag大写 解析为FC组件节点 重新生成element  挂载props
    if (elementNode.tag[0] === elementNode.tag[0].toUpperCase()) {
        newFiberNode.nodeType = 'FunctionComponent'
        newFiberNode.stateNode = elementNode.ref
        const childElementTree = elementNode.ref.call(undefined, elementNode.props)    //! 挂载props
        elementNode._child = transformElementTreeToBinadyTree(childElementTree, elementNode) //! 重新生成新的二叉element树
    }
    //解析为text节点
    else if (elementNode.tag === 'text') {
        newFiberNode.nodeType = 'HostText'
        newFiberNode.text = elementNode.text
        createTextElement(newFiberNode)
    }
    //解析为普通dom节点
    else {
        newFiberNode.nodeType = 'HostComponent'
        createDomElement(newFiberNode)
    }

    // 更改状态
    newFiberNode.fiberFlags = 'update'

    return newFiberNode
}


//! ---------------初始创建fiberTree(废弃)--------------------
export function createFiberTree2(elementNode: ElementNode | TextElementNode, parentFiber: FiberNode): FiberNode {

    let newFiberNode = new FiberNode('mount', '$1')
    let childElement = elementNode._child
    let siblingElement = elementNode._sibling

    //todo 切换当前工作fiber
    global.workInprogressFiberNode = newFiberNode

    newFiberNode.tag = elementNode.tag
    newFiberNode._parent = parentFiber
    newFiberNode._element = elementNode
    elementNode.fiber = newFiberNode


    //如果tag大写 解析为FC组件节点 重新生成element  挂载props
    if (elementNode.tag[0] === elementNode.tag[0].toUpperCase()) {
        newFiberNode.nodeType = 'FunctionComponent'
        newFiberNode.stateNode = elementNode.ref
        const childElementTree = elementNode.ref.call(undefined, elementNode.props)    //! 挂载props
        childElement = transformElementTreeToBinadyTree(childElementTree, elementNode) //! 重新生成新的二叉element树
        elementNode._child = childElement
    }
    //解析为text节点
    else if (elementNode.tag === 'text') {
        newFiberNode.nodeType = 'HostText'
        newFiberNode.text = elementNode.text
        createTextElement(newFiberNode)
    }
    //解析为普通dom节点
    else {
        newFiberNode.nodeType = 'HostComponent'
        createDomElement(newFiberNode)
    }



    // 深度优先递归执行
    if (childElement) {
        const childFiber = createFiberTree(childElement, newFiberNode)
        newFiberNode._child = childFiber
    }
    if (siblingElement) {
        const siblingFiber = createFiberTree(siblingElement, parentFiber)
        newFiberNode._sibling = siblingFiber
    }

    // 更改状态
    newFiberNode.fiberFlags = 'update'

    return newFiberNode
}

//! -------------创建复制的alternate------------------
export function createAlternate(currentFiber: FiberNode): FiberNode {
    let alternateFiber = new FiberNode('mount', '$2')
    let child = currentFiber._child
    let sibling = currentFiber._sibling

    //! 将一些属性复制给workInProgress
    alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer
    alternateFiber.updateQueue = currentFiber.updateQueue
    alternateFiber.hookIndex = currentFiber.hookIndex
    alternateFiber.memorizedState = currentFiber.memorizedState
    alternateFiber.nodeType = currentFiber.nodeType
    alternateFiber.tag = currentFiber.tag
    alternateFiber.text = currentFiber.text
    //! 链接两个fiber 
    alternateFiber.alternate = currentFiber
    currentFiber.alternate = alternateFiber
    //! 链接parent
    if (currentFiber._parent) {
        alternateFiber._parent = currentFiber._parent.alternate
        currentFiber._parent.alternate = alternateFiber._parent
    }

    // 深度优先递归执行
    if (child) {
        const childAlternateFiber = createAlternate(child)
        alternateFiber._child = childAlternateFiber
    }
    if (sibling) {
        const siblingAlternateFiber = createAlternate(sibling)
        alternateFiber._sibling = siblingAlternateFiber
    }

    // 更改状态
    alternateFiber.fiberFlags = 'update'

    return alternateFiber
}

//! -------------创建html并挂载到fiber节点上--------------------
export function createDomElement(fiber: FiberNode) {
    //找到父dom节点 将创建好的dom节点添加进去
    const parentDom = getParentDom(fiber)

    let domElement = document.createElement(fiber.tag)
    handleProps(fiber, domElement)
    parentDom.appendChild(domElement)
    fiber.stateNode = domElement

    return domElement
}

//! -------------创建text节点并挂载到fiber节点上--------------------
export function createTextElement(fiber: FiberNode) {
    //找到父dom节点 将创建好的dom节点添加进去
    const parentDom = getParentDom(fiber)

    let textElement = document.createTextNode(fiber.text)
    parentDom.appendChild(textElement)
    fiber.stateNode = textElement

    return textElement
}

//! ----------找到父dom节点---------------------
function getParentDom(fiber: FiberNode) {

    let parentNode = fiber._parent
    let parentDom = parentNode?.stateNode

    if (!parentNode) {
        return document.getElementById('root')
    }

    while (typeof parentDom === 'function') {
        parentNode = parentNode._parent
        if (!parentNode) {
            return document.getElementById('root')
        }
        parentDom = parentNode.stateNode
    }


    return parentDom
}

//! 对标签中的属性进行处理 给dom节点添加标签 (未完成)
export function handleProps(fiber: FiberNode, dom: HTMLElement | any) {

    const props = fiber._element.props

    for (let key in props) {
        const value = props[key]
        switch (key) {
            //todo  处理className 
            case 'className':
                dom.setAttribute("class", value);
                break;

            //todo  处理class
            case 'class':
                dom.setAttribute("class", value);
                break;

            //todo  处理点击事件(还需处理其他事件)
            case 'onClick':
                dom.onclick = value
                break;

            //todo  处理其他
            default:
                dom.setAttribute(key, value);
                break;
        }
    }
}














//! 二叉树遍历方法
function traversalFiber(rootFiber) {
    const res = []
    const stack = []

    if (rootFiber) stack.push(rootFiber)

    while (stack.length) {
        const n = stack.pop()
        // n为此时遍历到的fiber

        // 执行处理逻辑
        if (n.child) stack.push(n.child)
        if (n.sibling) stack.push(n.sibling)
    }

    return res
}


//todo 深度优先遍历  优先进入child  再进入sibling 都无的情况返回parent 进入sibling （交替执行begin和completeWork）
export function createFiberWorkLoop2(elementNode: ElementNode | TextElementNode) {

    if (Symbol.keyFor(elementNode.$$typeof) === 'textElement') {
        console.log('执行completeWork', elementNode.$$typeof);
        if (elementNode._child) {
            createFiberWorkLoop(elementNode._child)
        }
        if (elementNode._sibling) {
            createFiberWorkLoop(elementNode._sibling)
        }
    }


    else {
        console.log('执行beginWork', elementNode.$$typeof);
        if (elementNode._child) {
            createFiberWorkLoop(elementNode._child)
        }
        if (elementNode._sibling) {
            createFiberWorkLoop(elementNode._sibling)
        }
        console.log('执行completeWork', elementNode.$$typeof);
    }



}

//todo 深度优先遍历  构建fiber树
export function createFiberWorkLoop(elementNode: ElementNode | TextElementNode) {

    console.log('执行beginWork', elementNode.$$typeof);

    if (elementNode._child) {
        console.log('进入child');
        createFiberWorkLoop(elementNode._child)
    }
    if (elementNode._sibling) {
        console.log('进入sibling');
        createFiberWorkLoop(elementNode._sibling)
    }

}


function test() {
    const obj = {
        $$typeof: Symbol('lzyElement'),
        tag: "div",
        props: null,
        children: [
            {
                $$typeof: Symbol('lzyElement'),
                tag: "div",
                props: {
                    id: 1,
                    name: "张三"
                },
                children: [
                    {
                        $$typeof: Symbol('lzyTextElement'),
                        text: "文字内容"
                    },
                    {
                        $$typeof: Symbol('lzyElement'),
                        tag: "div",
                        props: {
                            id: 1,
                            name: "张三"
                        },
                        children: [
                            {
                                text: "1"
                            }
                        ]
                    },
                    {
                        $$typeof: Symbol('lzyElement'),
                        tag: "div",
                        props: {
                            id: 1,
                            name: "张三"
                        },
                        children: [
                            {
                                text: "1"
                            }
                        ]
                    },
                    {
                        $$typeof: Symbol('lzyElement'),
                        tag: "div",
                        props: null,
                        children: [
                            {
                                text: "Child"
                            }
                        ]
                    }
                ]
            }
        ]
    }
    console.log(transformElementTreeToBinadyTree(obj, 1));
}

