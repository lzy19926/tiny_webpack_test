
import type { DOMEventName } from './domEventsName'
import type { ContainerElement, AnyNativeEvent, } from './eventRegister'
import { LzySyntheticEvent } from './SyntheticEvent'
import { FiberNode } from '../myReactCore/GlobalFiber'
import { TEXT_NODE } from '../myReactCore/Constance'
import { getFiberNodeFromDom } from '../myReactCore/Constance'
import { topLevelEventsToReactNames } from './eventRegister'
import {
  DiscreteEventPriority,
  ContinuousEventPriority,
  getCurrentUpdatePriority,
  setCurrentUpdatePriority
} from './EventPriority'


type DispatchListener = {
  fiber: null | FiberNode,
  listener: Function,
  targetDom: EventTarget, // 事件触发的真实dom
};
type EventDispatcher = {
  isCapture: boolean,
  event: LzySyntheticEvent, // lzy合成事件
  listeners: Array<DispatchListener>,
};
type DispatchQueue = Array<EventDispatcher>;

//todo 触发普通事件
export function dispatchEvent(
  domEventName: DOMEventName,
  targetContainer: ContainerElement,
  nativeEvent: AnyNativeEvent,
  targetFiber: null | FiberNode,
) {
  //1/ 准备需要的参数
  const nativeEventTarget = getEventTarget(nativeEvent); //获取触发事件的dom
  const dispatchQueue: DispatchQueue = []  // dispatchQueue 提取所有监听的处理函数放到 dispatchQueue 当中

  if (!targetFiber) {
    targetFiber = getFiberNodeFromDom(nativeEventTarget) //获取触发dom对应的fiber(源码中为blockedOn)
  }

  //2. 收集沿途的冒泡事件
  extractEvents(
    dispatchQueue,
    domEventName,
    targetFiber,
    nativeEvent,
    nativeEventTarget,
    targetContainer
  )

  //3.模拟捕获阶段和冒泡阶段的执行流程，去执行所有的监听处理函数。
  processDispatchQueue(dispatchQueue); // 这里isCapture变量写死了  需修改

  // if (domEventName == 'click') {
  // logger.log(domEventName, '触发dispatchEvent');
  // logger.log(nativeEvent, 'nativeEvent');
  // logger.log(targetFiber, 'targetFiber');
  // logger.log(targetContainer, 'targetContainer');
  // logger.log(nativeEventTarget, '原生事件target');
  // }
}

//todo 触发DiscreteEvent离散事件(最高优先级)  用户事件级别
// 全局维护了一个当前时间的优先级CurrentUpdatePriority, 默认为default级
// 触发click事件时, 修改当前优先级为Discrete,事件执行完毕后还原
export function dispatchDiscreteEvent(
  domEventName: DOMEventName,
  targetContainer: ContainerElement,
  nativeEvent: AnyNativeEvent,
) {
  const previousPriority = getCurrentUpdatePriority();

  try {
    setCurrentUpdatePriority(DiscreteEventPriority);
    dispatchEvent(domEventName, targetContainer, nativeEvent, null);
  } finally {
    setCurrentUpdatePriority(previousPriority); // 还原当前优先级
  }
}

//todo 触发ContinuousEvent持续事件(次高优先级)
export function dispatchContinuousEvent(
  domEventName: DOMEventName,
  targetContainer: ContainerElement,
  nativeEvent: AnyNativeEvent,
) {
  const previousPriority = getCurrentUpdatePriority();

  try {
    setCurrentUpdatePriority(ContinuousEventPriority);
    dispatchEvent(domEventName, targetContainer, nativeEvent, null);
  } finally {
    setCurrentUpdatePriority(previousPriority); // 还原当前优先级
  }
}


//! ------阶段1----收集事件-----------------
function extractEvents(
  dispatchQueue: DispatchQueue,
  domEventName: DOMEventName,
  targetFiber: null | FiberNode,
  nativeEvent: AnyNativeEvent,
  nativeEventTarget: null | EventTarget,
  targetContainer: ContainerElement
) {

  //todo 同时收集onClickCatpure和普通onClick事件
  // 冒泡层层收集listeners
  // 分为捕获情况和非捕获情况的listeners不同
  let [listeners, capturedListeners] = accumulateTowEventListeners(targetFiber, domEventName, nativeEventTarget)

  //创建合成事件对象  queue推入
  if (listeners.length > 0) {
    const reactEventName = topLevelEventsToReactNames.get(domEventName)
    const reactEventType = domEventName
    const isCapture = false

    const event = new LzySyntheticEvent(
      reactEventName,
      reactEventType,
      targetFiber,
      nativeEvent,
      nativeEventTarget,
    )
    dispatchQueue.push({ event, listeners, isCapture });
  }
  //Capture事件推入queue
  if (capturedListeners.length > 0) {
    const reactEventName = topLevelEventsToReactNames.get(domEventName) + 'Capture'
    const reactEventType = domEventName
    const isCapture = true
    const listeners = capturedListeners

    const event = new LzySyntheticEvent(
      reactEventName,
      reactEventType,
      targetFiber,
      nativeEvent,
      nativeEventTarget,
    )

    dispatchQueue.push({ event, listeners, isCapture });
  }
}

// 仅收集onClick事件
function accumulateSingleEventListeners() {

}
// 同时收集onClick,onClickCapture事件 (仅收集dom类型节点上的事件)
// 从当前fiber出发,根据事件名"onClick",一直向上收集props(sourcePool)中所有事件
function accumulateTowEventListeners(
  targetFiber: FiberNode,
  domEventName: DOMEventName,
  nativeEventTarget: null | EventTarget
) {
  const listeners: Array<DispatchListener> = []
  const capturedListeners: Array<DispatchListener> = []

  const reactName = topLevelEventsToReactNames.get(domEventName);
  const reactNameCapture = reactName + 'Capture'

  if (reactName === undefined) return [listeners, capturedListeners];

  // 冒泡收集两种listener
  let currentFiber = targetFiber
  while (currentFiber) {
    let isHost = currentFiber.nodeType === 'HostComponent'
    let props = currentFiber._element?.props
    let nativeListener = props?.[reactName]
    let nativeListenerCapture = props?.[reactNameCapture]

    isHost && nativeListener && listeners.push(
      newDispatchListener(
        currentFiber,
        nativeListener,
        nativeEventTarget
      ))
    isHost && nativeListenerCapture && capturedListeners.push(
      newDispatchListener(
        currentFiber,
        nativeListenerCapture,
        nativeEventTarget
      ))
    currentFiber = currentFiber._parent
  }

  return [listeners, capturedListeners]
}

// 创建一个newDispatchListener实例
function newDispatchListener(
  fiber: null | FiberNode,
  listener: Function,
  targetDom: EventTarget,
): DispatchListener {
  return {
    fiber,
    listener,
    targetDom
  }
}

// 从原生event对象中获取target
function getEventTarget(nativeEvent: any): EventTarget {
  // 兼容IE9
  let target = nativeEvent.target || nativeEvent.srcElement || window;

  if (target.correspondingUseElement) {
    target = target.correspondingUseElement;
  }
  // 兼容Safari
  return target.nodeType === TEXT_NODE ? target.parentNode : target;
}



//! ------阶段2--模拟捕获阶段和冒泡阶段的执行流程，去执行所有的监听处理函数。------------
function processDispatchQueue(dispatchQueue: DispatchQueue) {
  if (dispatchQueue.length === 0) return

  for (let i = 0; i < dispatchQueue.length; i++) {
    let isCapture = dispatchQueue[i]?.isCapture

    isCapture
      ? executeDispatch_Capture(dispatchQueue[i])
      : executeDispatch_Bubble(dispatchQueue[i])
  }
}

// 模拟捕获阶段的事件执行(从父->子)
function executeDispatch_Bubble(eventDispatcher: EventDispatcher) {
  const { event, listeners } = eventDispatcher

  let previousFiber; // 记录上一个listener记录的fiber(如果不符合则退出执行)(应该是react内部为了处理fiber获取错误上的锁)
  for (let i = listeners.length - 1; i >= 0; i--) {
    const { fiber, listener, targetDom } = listeners[i];
    if (fiber !== previousFiber && event.isPropagationStopped()) return

    executeDispatch(event, listener, targetDom);
    previousFiber = fiber;
  }
}

// 模拟冒泡阶段的事件执行(从子->父)
function executeDispatch_Capture(eventDispatcher: EventDispatcher) {
  const { event, listeners } = eventDispatcher

  let previousFiber; // 记录上一个listener记录的fiber(如果不符合则退出执行)(应该是react内部为了处理fiber获取错误上的锁)
  for (let i = 0; i < listeners.length; i++) {
    const { fiber, listener, targetDom } = listeners[i];
    if (fiber !== previousFiber && event.isPropagationStopped()) return

    executeDispatch(event, listener, targetDom);
    previousFiber = fiber;
  }
}

// 执行listener
function executeDispatch(
  event: LzySyntheticEvent,
  listener: Function,
  currentTarget: EventTarget,
): void {
  event.currentTarget = currentTarget;

  try {
    listener.call(null, event)
  } catch (error) {
    throw new Error(error)
  }

  event.currentTarget = null;
}