import { scheduleFiberNode, markRef } from './Schedular'
import { FiberNode, global } from './GlobalFiber'
import { after_FirstReconcile_Hook } from './concurrent'
import { commitPart_First, commitPart_Update } from './commit'
import { reconcileElement_concurrent, createContainerFiber } from '../myJSX/reconcileElement'
import { updateReconcileElement } from '../myJSX/reconcile_update'
import { createElement } from '../myJSX/createElement'
import { startSyntheticEventSystem } from '../myEvent/eventRegister'

//! ----------遍历fiber  收集effect 挂载到本次root节点 识别删除节点------------------
function finishedWork(workInProgressFiber: FiberNode, currentFiber: FiberNode) {
    // 遍历fiber树 将所有Effect添加进root节点的update环链表中
    const root = workInProgressFiber
    let rootUpdateQueue = { firstEffect: null, lastEffect: null }

    finishedWorkLoop(workInProgressFiber, rootUpdateQueue, 'root')

    // 处理好的updateQueue成为到本次root节点的updateQueue
    root.updateQueue = rootUpdateQueue

    return root
}

//! 遍历fiber  拼接所有的effect   
function finishedWorkLoop(workInProgressFiber: FiberNode, rootUpdateQueue: any, tag?: string) {

    // 将updateQueue拼接到fiber的queue上
    collectEffect(workInProgressFiber, rootUpdateQueue)

    //diff两个节点 打上tag 生成Effect交给commit阶段更新
    // diffFiberNode(workInProgressFiber, null)

    // 继续遍历fiber树  拼接链表 深度优先递归执行
    const childFiber = workInProgressFiber._child
    const siblingFiber = workInProgressFiber._sibling

    if (childFiber) {
        finishedWorkLoop(childFiber, rootUpdateQueue)
    }
    if (siblingFiber && tag !== 'root') {// 第一次不进入组件节点的sibling
        finishedWorkLoop(siblingFiber, rootUpdateQueue)
    }
}

//! 将fiber的effect链表拼接起来
function collectEffect(fiber: FiberNode, rootUpdateQueue: any) {
    if (!fiber) return
    const fiberUpdateQueue = fiber.updateQueue

    if (fiberUpdateQueue && fiberUpdateQueue.lastEffect) {

        const first = fiberUpdateQueue.lastEffect.next
        const last = fiberUpdateQueue.lastEffect

        if (rootUpdateQueue.lastEffect) {
            rootUpdateQueue.lastEffect.next = first
            rootUpdateQueue.lastEffect = last
            last.next = rootUpdateQueue.firstEffect
        } else {
            rootUpdateQueue.firstEffect = first
            rootUpdateQueue.lastEffect = last
        }
    }
}

//TODO--- 进行优先级排序
function scheduleFiber(workInProgressFiber) {
    return workInProgressFiber
}

//遍历清空fiber树上的hookIndex 和 queue 和 EffectTag
function resetFiber(fiber: FiberNode) {
    if (!fiber) return
    fiber.hookIndex = 0
    fiber.updateQueue = null
    fiber.effectTag = undefined
    global.EffectList = { firstEffect: null, lastEffect: null, length: 0 }
    global.destoryEffectsArr = []

    if (fiber._child) {
        resetFiber(fiber._child)
    }
    if (fiber._sibling) {
        resetFiber(fiber._sibling)
    }
}

//!-------- 切换当前的workInprogress树  链接到当前element树上--------------
function connectElementAndWorkInProgress(workInProgressFiber: FiberNode) {
    const element = workInProgressFiber._element
    element.fiber = workInProgressFiber

    if (workInProgressFiber._child) {
        connectElementAndWorkInProgress(workInProgressFiber._child)
    }
    if (workInProgressFiber._sibling) {
        connectElementAndWorkInProgress(workInProgressFiber._sibling)
    }
}

// 遍历fiber树,根据effectTag执行对应操作(更新)
function beginWork(workInProgressFiber: FiberNode) {

    markRef(workInProgressFiber)

    beginWorkUpdate(workInProgressFiber)

    scheduleFiberNode(workInProgressFiber)

    if (workInProgressFiber._child) {
        beginWork(workInProgressFiber._child)
    }
    if (workInProgressFiber._sibling) {
        beginWork(workInProgressFiber._sibling)
    }

    return workInProgressFiber
}


//  不同类型的fiberNode执行不同的更新(更新后进行reconcile)
function beginWorkUpdate(workInProgressFiber: FiberNode) {

    const fiberType = workInProgressFiber.nodeType
    
    switch (fiberType) {
        //todo 函数组件 处理effects链表  
        case 'FunctionComponent':
            updateFunctionComponent(workInProgressFiber)
            break;
        //todo App根组件 处理effects链表  
        case 'AppNode':
            updateAppNode(workInProgressFiber)
            break;
        //todo dom节点  执行dom更新操作
        case 'HostComponent':
            updateHostComponent(workInProgressFiber)
            break;
        //todo text节点 单独更新
        case 'HostText':
            updateHostText(workInProgressFiber)
            break;

        default:
            break
    }

}

function updateFunctionComponent(wk: FiberNode) { }
function updateAppNode(wk: FiberNode) { }
function updateHostComponent(wk: FiberNode) { }
function updateHostText(wk: FiberNode) { }

//! ----------------首屏渲染----------------------------
function render(rootElement: any, rootDom: HTMLElement) {
    console.log('------------first render-------------');

    startSyntheticEventSystem(rootDom) //开启合成事件系统

    const containerFiber = createContainerFiber(rootDom)

    const root = reconcileElement_concurrent(rootElement, containerFiber)  // 新老ele进行调和(生成element树 转换为二叉fiber树)

    // 注册首屏渲染后的钩子
    after_FirstReconcile_Hook(() => {
        const beginWorkFiber = beginWork(root.fiber)

        const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

        const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

        commitPart_First(rootFiber)// commit阶段 一并更新dom

        console.log('首屏渲染生成的fiber', rootFiber);

    })

    return root
}

//! ----------------综合updateRender方法-------------------
function updateRender(functionComponent: Function, workInProgressFiber: FiberNode, currentFiber: FiberNode) {
    console.log('------------update render-------------');

    // 切换全局renderTag
    global.renderTag = 'update'

    //更新render时需要先将fiber的数据重置  重新挂载数据
    resetFiber(workInProgressFiber)
    resetFiber(currentFiber)

    // 更换workinProgress树 链接到当前vdom上
    connectElementAndWorkInProgress(workInProgressFiber)


    // 生成新的element树
    const newRootElement = createElement(functionComponent)
    const oldRootElement = currentFiber._element

    // 更新的根节点需要继承老节点的props(否则内层更新props会丢失)
    newRootElement.props = oldRootElement.props

    const { newEle } = updateReconcileElement(newRootElement, oldRootElement)    // 新老ele进行调和(生成element树 转换为二叉fiber树)

    const beginWorkFiber = beginWork(newEle.fiber) // 遍历fiber树,根据effectTag执行对应操作(更新)

    const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

    const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

    commitPart_Update(rootFiber)// commit阶段 一并更新dom

}

//! -------------------渲染路由页面------------------
function renderRoute(rootElement: any, containerFiber: FiberNode) {
    //需要先清空之前的effectList
    global.EffectList = { firstEffect: null, lastEffect: null, length: 0 }
    //清空路由内部元素
    containerFiber._child = undefined
    containerFiber.stateNode.innerHTML = null

    const root = reconcileElement_concurrent(rootElement, containerFiber)  // 新老ele进行调和(生成element树 转换为二叉fiber树)

    // 注册首屏渲染后的钩子
    after_FirstReconcile_Hook(() => {

        const beginWorkFiber = beginWork(root.fiber)

        const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

        const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

        commitPart_First(rootFiber)// commit阶段 一并更新dom

        console.log('路由渲染渲染生成的fiber', rootFiber);

    })

    return root
}

//TODO 卸载应用方法
function unmountAtRoot(rootDom: HTMLElement) {

    rootDom.innerHTML = null

    global.workInprogressFiberNode = null
    global.workInProgressHook = { currentHook: null }
    global.EffectList = { firstEffect: null, lastEffect: null, length: 0 }
    global.LayoutEffectList = { firstEffect: null, lastEffect: null, length: 0 }
    global.destoryEffectsArr = []
    global.renderTag = 'mount'
    global.isFirstRenderDone = false
}

export { render, updateRender, renderRoute, unmountAtRoot }