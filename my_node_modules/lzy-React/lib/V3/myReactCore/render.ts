
//1.  生成element树，转换为二叉fiber,保存fiber进map

//2.  生成新element树,查找map,有可复用的节点拿过来, 没有的打上标记添加,  map剩余的删除
import { scheduleFiberNode } from './Schedular'
import { FiberNode, global } from './GlobalFiber'
import { after_FirstReconcile_Hook } from './concurrent'
import { commitPart_First, commitPart_Update } from './commit'
import { reconcileElement_concurrent } from '../myJSX/reconcileElement'
import { updateReconcileElement } from '../myJSX/reconcile_update'
import { createElement } from '../myJSX/createElement'


//! ----------遍历fiber  收集effect 挂载到本次root节点 识别删除节点------------------
function finishedWork(workInProgressFiber: FiberNode, currentFiber: FiberNode) {
    // 遍历fiber树 将所有Effect添加进root节点的update环链表中
    const root = workInProgressFiber
    let rootUpdateQueue = { lastEffect: null }

    finishedWorkLoop(workInProgressFiber, rootUpdateQueue, 'root')

    // 处理好的updateQueue成为到本次root节点的updateQueue
    root.updateQueue = rootUpdateQueue

    return root
}

//! 遍历fiber  拼接所有的effect   
function finishedWorkLoop(workInProgressFiber: FiberNode, rootUpdateQueue: any, tag?: string) {

    // 将updateQueue拼接到fiber的queue上
    collectEffect(workInProgressFiber, rootUpdateQueue)

    //diff两个节点 打上tag 生成Effect交给commit阶段更新
    // diffFiberNode(workInProgressFiber, null)

    // 继续遍历fiber树  拼接链表 深度优先递归执行
    const childFiber = workInProgressFiber._child
    const siblingFiber = workInProgressFiber._sibling

    if (childFiber) {
        finishedWorkLoop(childFiber, rootUpdateQueue)
    }
    if (siblingFiber && tag !== 'root') {// 第一次不进入组件节点的sibling
        finishedWorkLoop(siblingFiber, rootUpdateQueue)
    }
}

//! 将fiber的effect链表拼接到
function collectEffect(fiber: FiberNode, rootUpdateQueue: any) {
    if (!fiber) return
    const fiberUpdateQueue = fiber.updateQueue

    if (fiberUpdateQueue && fiberUpdateQueue.lastEffect) {
        rootUpdateQueue.lastEffect = fiberUpdateQueue.lastEffect
        fiberUpdateQueue.lastEffect.next = rootUpdateQueue.lastEffect.next
    }
}

//TODO--- 进行优先级排序
function scheduleFiber(workInProgressFiber) {
    return workInProgressFiber
}

//遍历清空fiber树上的hookIndex 和 queue 和 EffectTag
function resetFiber(fiber: FiberNode) {
    if (!fiber) return
    fiber.hookIndex = 0
    fiber.updateQueue = null
    fiber.effectTag = undefined
    global.EffectList = { firstEffect: null, lastEffect: null, length: 0 }
    global.destoryEffectsArr = []

    if (fiber._child) {
        resetFiber(fiber._child)
    }
    if (fiber._sibling) {
        resetFiber(fiber._sibling)
    }
}

//!-------- 切换当前的workInprogress树  链接到当前element树上--------------
function connectElementAndWorkInProgress(workInProgressFiber: FiberNode) {
    const element = workInProgressFiber._element
    element.fiber = workInProgressFiber

    if (workInProgressFiber._child) {
        connectElementAndWorkInProgress(workInProgressFiber._child)
    }
    if (workInProgressFiber._sibling) {
        connectElementAndWorkInProgress(workInProgressFiber._sibling)
    }
}

// 遍历fiber树,根据effectTag执行对应操作(更新)
function beginWork(workInProgressFiber: FiberNode) {
    scheduleFiberNode(workInProgressFiber)

    if (workInProgressFiber._child) {
        beginWork(workInProgressFiber._child)
    }
    if (workInProgressFiber._sibling) {
        beginWork(workInProgressFiber._sibling)
    }

    return workInProgressFiber
}

//! ----------------首屏渲染----------------------------
function render(rootElement: any, rootDom: HTMLElement) {
    console.log('------------first render-------------');

    const root = reconcileElement_concurrent(rootElement)  // 新老ele进行调和(生成element树 转换为二叉fiber树)

    // 注册首屏渲染后的钩子
    after_FirstReconcile_Hook(() => {

        const beginWorkFiber = beginWork(root.fiber)

        const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

        const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

        commitPart_First(rootFiber)// commit阶段 一并更新dom

        console.log('首屏渲染生成的fiber', rootFiber);

    })

    return root
}

//! ----------------综合updateRender方法-------------------
function updateRender(functionComponent: Function, workInProgressFiber: FiberNode, currentFiber: FiberNode) {
    console.log('------------update render-------------');

    // 切换全局renderTag
    global.renderTag = 'update'

    //更新render时需要先将fiber的数据重置  重新挂载数据
    resetFiber(workInProgressFiber)
    resetFiber(currentFiber)

    // 更换workinProgress树 链接到当前vdom上
    connectElementAndWorkInProgress(workInProgressFiber)


    // 生成新的element树
    const newRootElement = createElement(functionComponent)
    const oldRootElement = currentFiber._element


    const { newEle } = updateReconcileElement(newRootElement, oldRootElement)    // 新老ele进行调和(生成element树 转换为二叉fiber树)


    const beginWorkFiber = beginWork(newEle.fiber) // 遍历fiber树,根据effectTag执行对应操作(更新)

    const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

    const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

    commitPart_Update(rootFiber)// commit阶段 一并更新dom

}


export { render, updateRender }