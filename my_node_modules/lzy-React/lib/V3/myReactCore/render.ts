import { scheduleFiberNode, markRef } from './Schedular'
import { FiberNode, global, RenderOptions } from './GlobalFiber'
import { after_FirstReconcile_Hook } from './concurrent'
import { commitPart_First, commitPart_Update } from './commit'
import { renderWork_concurrent, createContainerFiber } from '../myJSX/renderWork'
import { reconcileWork_sync } from '../myJSX/reconcileWork'
import { createElement } from '../myJSX/createElement'
import { startSyntheticEventSystem } from '../myEvent/eventRegister'
import { logger } from '../utils/logger'

//! ----------遍历fiber  收集effect 挂载到本次root节点 识别删除节点------------------
function finishedWork(workInProgressFiber: FiberNode, currentFiber: FiberNode) {
  // 遍历fiber树 将所有Effect添加进root节点的update环链表中
  const root = workInProgressFiber
  let rootUpdateQueue = { firstEffect: null, lastEffect: null }

  finishedWorkLoop(workInProgressFiber, rootUpdateQueue, 'root')

  // 处理好的updateQueue成为到本次root节点的updateQueue
  root.updateQueue = rootUpdateQueue

  return root
}

//! 遍历fiber  拼接所有的effect
function finishedWorkLoop(workInProgressFiber: FiberNode, rootUpdateQueue: any, tag?: string) {

  // 将updateQueue拼接到fiber的queue上
  collectEffect(workInProgressFiber, rootUpdateQueue)

  //diff两个节点 打上tag 生成Effect交给commit阶段更新
  // diffFiberNode(workInProgressFiber, null)

  // 继续遍历fiber树  拼接链表 深度优先递归执行
  const childFiber = workInProgressFiber._child
  const siblingFiber = workInProgressFiber._sibling

  if (childFiber) {
    finishedWorkLoop(childFiber, rootUpdateQueue)
  }
  if (siblingFiber && tag !== 'root') {// 第一次不进入组件节点的sibling
    finishedWorkLoop(siblingFiber, rootUpdateQueue)
  }
}

//! 将fiber的effect链表拼接起来
function collectEffect(fiber: FiberNode, rootUpdateQueue: any) {
  if (!fiber) return
  const fiberUpdateQueue = fiber.updateQueue

  if (fiberUpdateQueue && fiberUpdateQueue.lastEffect) {

    const first = fiberUpdateQueue.lastEffect.next
    const last = fiberUpdateQueue.lastEffect

    if (rootUpdateQueue.lastEffect) {
      rootUpdateQueue.lastEffect.next = first
      rootUpdateQueue.lastEffect = last
      last.next = rootUpdateQueue.firstEffect
    } else {
      rootUpdateQueue.firstEffect = first
      rootUpdateQueue.lastEffect = last
    }
  }
}

//TODO--- 进行优先级排序
function scheduleFiber(workInProgressFiber) {
  return workInProgressFiber
}

//清空全局的effect链表,重置所有fiber的EffectTag
function resetFiberEffect(workInProgressFiber: FiberNode, currentFiber: FiberNode) {
  global.EffectList = { firstEffect: null, lastEffect: null, length: 0 }
  global.destoryEffectsArr = []

  resetEffectTag(workInProgressFiber)
  resetEffectTag(currentFiber)
}
// 递归清除effectTag
function resetEffectTag(fiber: FiberNode) {
  if (!fiber) return
  fiber.effectTag = undefined
  fiber._child && resetEffectTag(fiber._child)
  fiber._sibling && resetEffectTag(fiber._sibling)
}

//!-------- 切换当前的workInprogress树  链接到当前element树上--------------
function connectElementAndWorkInProgress(workInProgressFiber: FiberNode) {
  const element = workInProgressFiber._element
  element.fiber = workInProgressFiber

  if (workInProgressFiber._child) {
    connectElementAndWorkInProgress(workInProgressFiber._child)
  }
  if (workInProgressFiber._sibling) {
    connectElementAndWorkInProgress(workInProgressFiber._sibling)
  }
}

// 遍历fiber树,根据effectTag执行对应操作(更新)
function beginWork(workInProgressFiber: FiberNode) {

  markRef(workInProgressFiber)

  beginWorkUpdate(workInProgressFiber)

  scheduleFiberNode(workInProgressFiber)

  if (workInProgressFiber._child) {
    beginWork(workInProgressFiber._child)
  }
  if (workInProgressFiber._sibling) {
    beginWork(workInProgressFiber._sibling)
  }

  return workInProgressFiber
}


//  不同类型的fiberNode执行不同的更新(更新后进行reconcile)
function beginWorkUpdate(workInProgressFiber: FiberNode) {

  const fiberType = workInProgressFiber.nodeType

  switch (fiberType) {
    //todo 函数组件 处理effects链表
    case 'FunctionComponent':
      updateFunctionComponent(workInProgressFiber)
      break;
    //todo App根组件 处理effects链表
    case 'AppNode':
      updateAppNode(workInProgressFiber)
      break;
    //todo dom节点  执行dom更新操作
    case 'HostComponent':
      updateHostComponent(workInProgressFiber)
      break;
    //todo text节点 单独更新
    case 'HostText':
      updateHostText(workInProgressFiber)
      break;
    //todo ForwardRef类型节点处理
    case "ForwardRef":
      updateForwardRef(workInProgressFiber)
    default:
      break
  }

}

function updateFunctionComponent(wk: FiberNode) { }
function updateAppNode(wk: FiberNode) { }
function updateHostComponent(wk: FiberNode) { }
function updateHostText(wk: FiberNode) { }
function updateForwardRef(wk: FiberNode) {
  // 该函数主要是解除传递ref的限制 (检测到是forwardRef节点)
  // 对函数组件,会限制ref的传递
}

//! ----------------首屏渲染----------------------------
function render(rootElement: any, rootDom: HTMLElement, options?: RenderOptions) {

  initOptions(options)

  logger.log('------------first render-------------');

  startSyntheticEventSystem(rootDom) //开启合成事件系统

  const containerFiber = createContainerFiber(rootDom)

  const root = renderWork_concurrent(rootElement, containerFiber)  // 新老ele进行调和(生成element树 转换为二叉fiber树)

  // 注册首屏渲染后的钩子
  after_FirstReconcile_Hook(() => {
    const beginWorkFiber = beginWork(root.fiber)

    const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

    const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

    commitPart_First(rootFiber)// commit阶段 一并更新dom

    logger.log('首屏渲染生成的fiber', rootFiber);

  })

  return root
}

//! ----------------综合updateRender方法-------------------
function updateRender(functionComponent: Function, workInProgressFiber: FiberNode, currentFiber: FiberNode) {
  logger.log('------------update render-------------');

  // 切换全局renderTag
  global.renderTag = 'update'

  //需要先重置所有effect相关的数据
  resetFiberEffect(workInProgressFiber, currentFiber)

  // 更换workinProgress树 链接到当前vdom上
  connectElementAndWorkInProgress(workInProgressFiber)

  // 生成新的element树
  const newRootElement = createElement(functionComponent)
  const oldRootElement = currentFiber._element

  // 更新的根节点需要继承老节点的props(否则内层更新props会丢失)
  newRootElement.props = oldRootElement.props

  const { newEle } = reconcileWork_sync(newRootElement, oldRootElement)    // 新老ele进行调和(生成element树 转换为二叉fiber树)

  const beginWorkFiber = beginWork(newEle.fiber) // 遍历fiber树,根据effectTag执行对应操作(更新)

  const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

  const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

  commitPart_Update(rootFiber)// commit阶段 一并更新dom

}

//! -------------------渲染路由页面------------------
function renderRoute(rootElement: any, containerFiber: FiberNode) {
  //需要先清空之前的effectList
  global.EffectList = { firstEffect: null, lastEffect: null, length: 0 }
  //清空路由内部元素
  containerFiber._child = undefined;
  (containerFiber.stateNode as HTMLElement).innerHTML = null;

  const root = renderWork_concurrent(rootElement, containerFiber)  // 新老ele进行调和(生成element树 转换为二叉fiber树)

  // 注册首屏渲染后的钩子
  after_FirstReconcile_Hook(() => {

    const beginWorkFiber = beginWork(root.fiber)

    const finishedWorkFiber = finishedWork(beginWorkFiber, null)    // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了

    const rootFiber = scheduleFiber(finishedWorkFiber) // 调度fiber,根据优先级排序任务

    commitPart_First(rootFiber)// commit阶段 一并更新dom

    logger.log('路由渲染渲染生成的fiber', rootFiber);

  })

  return root
}

//TODO 卸载应用方法
function unmountAtRoot(rootDom: HTMLElement) {

  rootDom.innerHTML = null

  global.workInprogressFiberNode = null
  global.workInProgressHook = { currentHook: null }
  global.EffectList = { firstEffect: null, lastEffect: null, length: 0 }
  global.LayoutEffectList = { firstEffect: null, lastEffect: null, length: 0 }
  global.destoryEffectsArr = []
  global.renderTag = 'mount'
  global.isFirstRenderDone = false
}

// 初始化配置
function initOptions(options: RenderOptions) {
  if (!options) return

  options.openLogger && logger.open()
}
export { render, updateRender, renderRoute, unmountAtRoot }