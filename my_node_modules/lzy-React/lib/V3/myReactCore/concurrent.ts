
// 本工具提供了时间切片和concurrent模式的方法实现
//! react会定义每一帧的工作时间 默认5s (每16.6ms会执行5ms的React任务,剩下的时间交给浏览器,防止卡顿)
//! shouldYieldToHost在外部执行workLoop时(render时)  判断是否让出主线程



//!  --------------切片执行while循环类---------------
export class WhileCodeCutter {
    yieldInterval: number            // 每一帧留给react的工作时间
    deadLine: number                 // 本帧react应该停止的时间
    isMessageChannelRunnig: boolean  // 本帧react的任务是否在执行
    scheduledHostCallBack: any       // 已经计算过的用户事件(workLoop)
    onWhileDone: Function            // 切片while结束后的回调
    channel: MessageChannel          // 本切片使用的channel
    port: MessagePort                // 本切片使用的channelPort
    getCurrentTime: Function          //获取当前时间(从开始渲染计算)
    shouldYieldToHost: Function       //是否超过deadLine  让出JS主线程给用户

    constructor() {
        this.yieldInterval = 5
        this.deadLine = 0
        this.isMessageChannelRunnig = false
        this.scheduledHostCallBack = null
        this.channel = new MessageChannel()
        this.port = this.channel.port2
        this.onWhileDone = () => { }
        this.getCurrentTime = () => performance.now()
        this.shouldYieldToHost = () => this.getCurrentTime() >= this.deadLine
        this.channel.port1.onmessage = this.performWorkUntilDeadline
        this.checkEnvironment()
        debugger
    }

    // 检查使用环境
    checkEnvironment() {
        if (typeof window === 'undefined') {
            throw new Error('请在浏览器环境下使用')
        }
        if (!MessageChannel) {
            throw new Error('本工具仅兼容所有人类使用的浏览器(请不要使用IE谢谢)')
        }
    }


    // 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
    requestHostCallback(cb) {
        this.scheduledHostCallBack = cb
        if (!this.isMessageChannelRunnig) {
            this.isMessageChannelRunnig = true
            this.port.postMessage(null)
        }
    }

    // 执行单次切片的逻辑
    performWorkUntilDeadline() {
        console.log(`执行单个${this.yieldInterval}ms的任务`);
        // 如果没有用户任务  状态直接改为false
        if (!this.scheduledHostCallBack) {
            this.isMessageChannelRunnig = false
        }
        // 如果有用户任务
        if (this.scheduledHostCallBack !== null) {
            let currentTime = this.getCurrentTime()
            this.deadLine = currentTime + this.yieldInterval // 停止react任务的时间
            const shouldContinue = true

            try {
                const hasMoreWork = this.scheduledHostCallBack(shouldContinue, currentTime) // 执行workLoop
                // 如果执行完毕  初始化工作环境
                if (!hasMoreWork) {
                    this.isMessageChannelRunnig = false
                    this.scheduledHostCallBack = null
                }
                // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
                if (hasMoreWork) {
                    this.port.postMessage(null)
                }
            } catch (error) {
                this.port.postMessage(null);
                throw error;
            }
        }
    }

    //!  --------------封装的切片执行while循环函数---------------
    While(getCondition: Function, handler: Function, yieldInterval?: number, afterWhile?: Function) {
        // 设置切片时间
        yieldInterval = yieldInterval

        // 创建whild循环体
        let workLoop = () => {
            while (!this.shouldYieldToHost() && getCondition()) {
                handler()
            }
            if (!getCondition()) {
                this.onWhileDone()
            }
            return getCondition()
        }

        this.requestHostCallback(workLoop);
    }

}


//!  --------------切片执行while循环函数---------------
// 使用说明  
// 可以将while循环根据拆成多个短任务,每帧执行一个短任务 (通过yieldInterval设置短任务时间)

// 使用案例
// while (a < 100) {
//     a++
// }

// 将上面的一个while长任务拆分成多个5ms的短任务
// const getCondition = () => a < 100
// const handler = () => { a++ }
// concurrentWhile(getCondition, handler, 5)

//  getCondition :()=>boolean   // 获取while循环条件的函数
//  handler:()=>any             // while循环体
//  yieldInterval? :number      // 每帧执行while循环的时间ms

export function concurrentWhile(getCondition: Function, handler: Function, yieldInterval?: number, afterWhile?: Function) {

    // 判断环境
    if (typeof window === 'undefined') {
        throw new Error('请在浏览器环境下使用')
    }
    if (!MessageChannel) {
        throw new Error('本工具仅兼容所有人类使用的浏览器(请不要使用IE谢谢)')
    }


    let getCurrentTime = () => performance.now();
    let deadLine = 0                       // 本帧react应该停止的时间
    let isMessageChannelRunnig = false     // 本帧react的任务是否在执行
    let scheduledHostCallBack = null       // 已经计算过的用户事件(workLoop)
    let shouldYieldToHost = () => getCurrentTime() >= deadLine   // 超过deadLine时让出JS主线程给用户
    let channel = new MessageChannel()     // 建立通信 port用来发布任务
    let port = channel.port2               // 当port1收到消息时会执行react渲染短任务


    // 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
    const requestHostCallback = (cb) => {
        scheduledHostCallBack = cb
        if (!isMessageChannelRunnig) {
            isMessageChannelRunnig = true
            port.postMessage(null)
        }
    }

    // 执行单次切片的逻辑
    const performWorkUntilDeadline = () => {
        console.log(`-----${yieldInterval}ms切片-----`);
        // 如果没有用户任务  状态直接改为false
        if (!scheduledHostCallBack) {
            isMessageChannelRunnig = false
        }
        // 如果有用户任务
        if (scheduledHostCallBack !== null) {
            let currentTime = getCurrentTime()
            deadLine = currentTime + yieldInterval // 停止react任务的时间
            const shouldContinue = true

            try {
                const hasMoreWork = scheduledHostCallBack(shouldContinue, currentTime) // 执行workLoop
                // 如果执行完毕  初始化工作环境
                if (!hasMoreWork) {
                    isMessageChannelRunnig = false
                    scheduledHostCallBack = null
                }
                // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
                if (hasMoreWork) {
                    port.postMessage(null)
                }
            } catch (error) {
                port.postMessage(null);
                throw error;
            }
        }
    }

    // 初始化工作环境
    yieldInterval = yieldInterval || 5 // 每一帧留给react的工作时间
    channel.port1.onmessage = performWorkUntilDeadline


    // 创建whild循环体
    let workLoop = () => {
        while (!shouldYieldToHost() && getCondition()) {
            handler()
        }
        return getCondition()
    }

    requestHostCallback(workLoop);
}



// 各种while执行完毕后的钩子
export const concurrentWhileHook = {
    afterFirstReconcile: undefined,
    afterUpdateReconcile: undefined,
}



// 注册钩子函数
export function after_UpdateReconcile_Hook(callback: Function) {
    concurrentWhileHook.afterUpdateReconcile = callback
}

export function after_FirstReconcile_Hook(callback: Function) {
    concurrentWhileHook.afterFirstReconcile = callback
}