
import { diffUseEffect } from './Schedular'
import { FiberNode, global } from './GlobalFiber'
import { handleProps } from './handleProps'
import { concurrentWhile, concurrentWhileHook, after_FiberNodeMutation_Hook } from './concurrent'
import { insertAfter, findPrevSiblingFiber, getParentDom, isHTMLElement } from '../utils/utils'
import { patchFiberNodeToDom } from './Constance'
//! -----------------模拟Commit阶段-----------------------------
//! 分为三部分  beforeMutation  mutation  layout阶段
//! before 前置处理  mutation 渲染dom节点   layout  处理useEffect useLayoutEffect
export function commitPart_First(finishedWorkFiber: FiberNode) {

    beforeMutation(finishedWorkFiber)  // beforeMutation阶段

    commitFiberNodeMutation_concurrent(global.EffectList) //  mutation阶段 

    //todo  layout阶段  调用Effects链表 执行create函数() 
    // 注册钩子  //todo 处理ref
    after_FiberNodeMutation_Hook(() => {
        LayoutMutation(global.EffectList)
    })

}

export function commitPart_Update(finishedWorkFiber: FiberNode) {

    beforeMutation(finishedWorkFiber)   // beforeMutation阶段

    commitFiberNodeMutation_concurrent(global.EffectList)  // mutation阶段 

    //todo  layout阶段  调用Effects链表 执行create函数()
    // 注册钩子  //todo 处理ref
    after_FiberNodeMutation_Hook(() => {
        LayoutMutation(global.EffectList)
    })

}

//! beforeMutation阶段 (将收集好的useEffect生成一个Effect 推入链表)
function beforeMutation(finishedWorkFiber: FiberNode) {
    diffUseEffect(finishedWorkFiber)
}

//! 通过concurrent时间切片优化的mutation阶段
function commitFiberNodeMutation_concurrent(EffectList: any, lane?: any) {

    console.log('本次更新的EffectList', EffectList);

    let currentEffect = EffectList.firstEffect

    //! 切片执行while遍历
    const getCondition = () => currentEffect !== null
    concurrentWhile(getCondition, () => {
        let effectTag = currentEffect.tag
        let targetFiber = currentEffect.targetFiber
        switch (effectTag) {
            case 'Placement'://todo  添加
                commitPlacement(targetFiber)
                break;
            case 'Delete'://todo  删除
                commitDeletion(targetFiber)
                break;
            case 'Update'://todo  更新
                commitUpdate(targetFiber)
                break;
            case 'UseEffect'://todo 调用了useEffect钩子
                commitUpdate(targetFiber)
            default:
                // commitUpdate(targetFiber) //todo 处理更新链表(effect链表和其他的effect应该是在一起的)
                break;
        }
        currentEffect = currentEffect.next

        // 执行结束回调
        if (!getCondition()) {
            const cb = concurrentWhileHook.afterFiberNodeMutation
            if (typeof cb === 'function') {
                cb()
            }
        }
    })
}

//! layout阶段
function LayoutMutation(EffectList: any, lane?: any) {
    let currentEffect = EffectList.firstEffect
    while (currentEffect !== null) {
        let effectTag = currentEffect.tag
        let targetFiber = currentEffect.targetFiber
        if (effectTag === 'UpdateRef') {
            commitAttachRef(targetFiber)
        }
        currentEffect = currentEffect.next
    }
}

//todo 待完成 插入dom节点
function commitPlacement(finishedWorkFiber: FiberNode) {

    const fiberType = finishedWorkFiber.nodeType
    switch (fiberType) {
        //todo 函数组件 处理effects链表  
        case 'FunctionComponent':
            //遍历effect更新链表  执行每个上一次的destory和本次create,并挂载destory
            //在之前finishedWork阶段已经将所有effects收集 挂载到finishedWorkFiber上
            // callDestoryAndUnmountDestoryList(finishedWorkFiber)
            // callCreateAndMountDestoryList(finishedWorkFiber)
            break;
        //todo App根组件 处理effects链表  
        case 'AppNode':
            // callDestoryAndUnmountDestoryList(finishedWorkFiber)
            // callCreateAndMountDestoryList(finishedWorkFiber)
            break;
        //todo dom节点  执行dom更新操作
        case 'HostComponent':
            createDomElement(finishedWorkFiber)
            break;
        //todo text节点 单独更新
        case 'HostText':
            createDomElement(finishedWorkFiber)
            break;
        //todo ContextProvider节点
        case 'ContextProvider':
            break;

    }
}

// todo 不同类型的fiberNode执行不同的更新 (在这里处理useEffect链表)
function commitUpdate(finishedWorkFiber: FiberNode) {

    const fiberType = finishedWorkFiber.nodeType
    switch (fiberType) {
        //todo 函数组件 处理effects链表  
        case 'FunctionComponent':
            //遍历effect更新链表  执行每个上一次的destory和本次create,并挂载destory
            //在之前finishedWork阶段已经将所有effects收集 挂载到finishedWorkFiber上
            callDestoryAndUnmountDestoryList(finishedWorkFiber)
            callCreateAndMountDestoryList(finishedWorkFiber)
            break;
        //todo App根组件 处理effects链表  
        case 'AppNode':
            callDestoryAndUnmountDestoryList(finishedWorkFiber)
            callCreateAndMountDestoryList(finishedWorkFiber)
            break;
        //todo dom节点  执行dom更新操作
        case 'HostComponent':
            commitUpdateDom(finishedWorkFiber)
            break;
        //todo text节点 单独更新
        case 'HostText':
            commitUpdateText(finishedWorkFiber)
    }

}

// todo 删除多余的currentFiber和dom节点
function commitDeletion(currentFiber: FiberNode) {
    // 删除dom节点
    const dom = currentFiber.stateNode
    if (typeof dom !== 'function') {
        dom.remove()
    }
}

//todo 更新fiber的ref属性   
function commitAttachRef(finishedWorkFiber: FiberNode) {
    var ref = finishedWorkFiber._element.ref
    var instance = finishedWorkFiber.stateNode
    var nodeType = finishedWorkFiber.nodeType

    // 先删除先前的ref
    if (!ref) {
        console.warn('请使用useRef创建ref容器实例')
        return
    }

    switch (nodeType) {
        case 'AppNode' || 'FunctionComponent':
            instance = finishedWorkFiber._child.stateNode
            break;
        case 'HostComponent' || 'HostText':
            instance = finishedWorkFiber.stateNode
            break;
    }

    // 给ref容器赋值
    ref.current = instance
}

//todo 记录  我这里直接遍历fiber树  发现有需要变更的节点直接进行变更,
//todo 而react中在render阶段遍历 发现变更 打上tag  生成update , 推入effect链表中  为了实现优先级调度

// 错误记录 : 赋值dom节点新的text后   没有handleProps   
// 因为新的click函数的获取在这里   如果不执行  每次点击执行的都是上一次的点击事件 
// 所以不更新视图
// todo dom节点的更新
function commitUpdateDom(finishedWorkFiber: FiberNode) {
    const domElement = finishedWorkFiber.stateNode
    if (typeof domElement === 'function') return
    handleProps(finishedWorkFiber, domElement)
}

//TODO text节点的更新
function commitUpdateText(finishedWorkFiber: FiberNode) {
    const domElement = finishedWorkFiber.stateNode
    if (typeof domElement === 'function') return

    handleProps(finishedWorkFiber, domElement)
    // ! 比较text是否变化 变化则更改dom
    let fiberText = finishedWorkFiber.text
    let domText = domElement.textContent

    if (domText !== fiberText) {
        domElement.textContent = fiberText
    }
}

//! 执行所有上一次挂载的destory  并销毁
function callDestoryAndUnmountDestoryList(finishedWorkFiber: FiberNode) {
    //! (此时生成了新的fiber  老fiber会被unmount) 所以destory是在组件unmount时执行的
    var updateQueue = finishedWorkFiber.updateQueue;
    var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;

    if (lastEffect !== null) {
        var firstEffect = lastEffect.next;
        var currentEffect = firstEffect;

        do {
            //todo 判断是否需要执行 执行destory
            callDestoryByTag(currentEffect)
            currentEffect = currentEffect.next
        }
        while (currentEffect !== firstEffect)
    }
}

//! 执行所有的create 挂载destory
function callCreateAndMountDestoryList(finishedWorkFiber: FiberNode) {
    const updateQueue = finishedWorkFiber.updateQueue
    var lastEffect = updateQueue !== null ? updateQueue.lastEffect : null;



    //todo do while遍历effect环链表 执行destory
    if (lastEffect !== null) {
        var firstEffect = lastEffect.next
        var currentEffect = firstEffect;

        do {
            //todo 判断是否需要执行 执行create

            callCreateByTag(currentEffect)
            currentEffect = currentEffect.next
        }
        while (currentEffect !== firstEffect)
    }
}

//! 判断tag  执行create函数
function callCreateByTag(effect: any) {

    //判断effectTag决定是否执行Effect(mount和dep变更时执行)
    //React底层通过二进制来打tag
    const isFiberMount = Boolean(global.renderTag === 'mount')
    const isDepChange = Boolean(effect.tag === 'depChanged')
    const isNullDeps = Boolean(effect.tag === 'nullDeps')
    const isNoDeps = Boolean(effect.tag === 'noDeps')
    let needCallCreate = false
    //根据不同情况 决定是否执行create 
    if ((isFiberMount || isDepChange || isNullDeps) || (isFiberMount && isNoDeps)) {
        needCallCreate = true
    }

    //判断tag如果需要执行  执行create 挂载destory
    if (needCallCreate) {
        const create = effect.create
        effect.destory = create()
    }

}

//! 判断tag  执行destory函数(需要修改)
function callDestoryByTag(effect: any) {

    //判断effectTag决定是否执行Effect(mount和dep变更时执行)
    //React底层通过二进制来打tag
    const isFiberMount = Boolean(global.renderTag === 'mount')
    const isDepChange = Boolean(effect.tag === 'depChanged')
    const isNullDeps = Boolean(effect.tag === 'nullDeps')
    const isNoDeps = Boolean(effect.tag === 'noDeps')
    let needCallDestory = false

    //根据不同情况 决定是否执行create 
    if ((isFiberMount || isDepChange || isNullDeps) || (isFiberMount && isNoDeps)) {
        needCallDestory = true
    }

    //判断tag如果需要执行  执行并销毁effect上的destory
    var destory = effect.destory;

    if (destory !== undefined && needCallDestory) {
        destory()
        effect.destory = undefined;
    }

}

//! -------------创建html并挂载到fiber节点上(源码为createInstance)--------------------
// 注意: React中,首屏渲染创建dom是在completeWork阶段执行,这里统一收集到commit阶段,
// 为了使用切片commit函数  
function createDomElement(fiber: FiberNode) {
    //找到父dom节点 将创建好的dom节点添加进去appendChild
    //如果有兄弟节点则插入insertBefore

    let newHtmlElement;
    if (fiber.nodeType === 'HostComponent') {
        newHtmlElement = document.createElement(fiber.tag)
    } else if (fiber.nodeType === 'HostText') {
        newHtmlElement = document.createTextNode(fiber.text)
    } else {
        return
    }

    const parentDom = getParentDom(fiber)
    const siblingDom = fiber?._sibling?.stateNode
    const prevDom = findPrevSiblingFiber(fiber)?.stateNode


    fiber.stateNode = newHtmlElement
    if (fiber.alternate) {
        fiber.alternate.stateNode = newHtmlElement
    }

    handleProps(fiber, newHtmlElement)

    patchFiberNodeToDom(fiber, newHtmlElement)

    // 如果没有siblingDom,直接从上一个节点后插入dom
    if (isHTMLElement(prevDom) && typeof prevDom !== 'function') {
        insertAfter(newHtmlElement, prevDom)
    }
    // 需要判断sibling是否为dom节点
    else if (isHTMLElement(siblingDom) && typeof siblingDom !== 'function') {
        parentDom.insertBefore(newHtmlElement, siblingDom)
    }
    else {
        parentDom.appendChild(newHtmlElement)
    }

    return newHtmlElement
}



