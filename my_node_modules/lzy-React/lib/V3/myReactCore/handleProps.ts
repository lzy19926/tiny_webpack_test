import { FiberNode } from './GlobalFiber'

// 保存在节点上的内部属性
const internalPropsKey = '__lzyReactProps$';



// todo 处理并设置dom的Props 
export function handleProps(fiber: FiberNode, dom: HTMLElement | any) {

    // 获取本次渲染的props对象(上一次渲染的props保存在dom实例中)
    const nextProps = fiber._element.props


    for (const propName in nextProps) {
        //todo  处理class 
        if (propName === 'className' || propName === 'class') {
            handleStyle(propName, dom, nextProps)
        }
        //todo 处理合成事件
        else if (propName[0] === 'o' && propName[1] === 'n') {
            handleEvent(propName, dom, nextProps)
        }
        // todo 处理其他
        else {
            dom.setAttribute(propName, nextProps[propName]);
        }
    }

    // 更新当前Dom上的props
    updateFiberPropsToDom(dom, nextProps)
}


// 保存/更新props到Dom节点实例中 (Dom节点,Text节点,Suspence节点)
// 创建节点   和  commit中处理完props后  进行更新
function updateFiberPropsToDom(node: Element, props: Object) {
    node[internalPropsKey] = props
}

// 从节点实例中获取当前的props (比如dom节点当前的click事件)
function getFiberCurrentPropsFromDom(node: Element): Object {
    return node[internalPropsKey] || {}
}

// todo --------处理合成事件-----------------
function handleEvent(
    propName: string,
    dom: Element,
    nextProps: Object
) {


    // 大小写处理
    if (propName[2].toLowerCase() === propName[2]) {
        console.warn(`请使用on+大写字母替代${propName},实现与原生区分`)
    }

    // 处理捕获事件 : onClickCapture
    // 删除Capture后缀  删除on前缀 如果使用了capture后缀则在listener中捕获
    let eventName = propName.toLowerCase().replace(/capture$/, '');
    const useCapture = propName !== eventName;
    eventName = eventName.slice(2);

    // 获取dom中的上一个eventHandler,更新为新的
    let prevEventHandler = getFiberCurrentPropsFromDom(dom)[propName]
    let eventHandler = nextProps[propName];

    // 删除上一个监听器(更新函数引用)
    if (typeof prevEventHandler === 'function') {
        dom.removeEventListener(eventName, prevEventHandler, useCapture)
    }
    // 添加一个监听器(更新函数引用)
    if (typeof eventHandler === 'function') {
        dom.addEventListener(eventName, eventHandler, useCapture)
    } else {
        debugger
        console.warn(`事件${propName}处理需要传递一个函数`)
    }

}

// todo ----------处理样式---------------
function handleStyle(
    propName: string,
    dom: Element,
    nextProps: Object
) {
    // 可同时使用class和className

    if (propName["class"] && propName["className"]) {
        console.warn("请不要混用属性class和className")
    }

    const className = nextProps[propName]

    dom.setAttribute("class", className);
}