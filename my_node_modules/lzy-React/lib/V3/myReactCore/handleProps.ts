import { FiberNode } from './GlobalFiber'
import { global } from './GlobalFiber'
import { getFiberCurrentPropsFromDom, updateFiberPropsToDom } from './Constance'
import { isEmpty } from '../utils/utils'

// todo 处理并设置dom的Props 
export function handleProps(fiber: FiberNode, dom: HTMLElement | any) {

    // 获取本次渲染的props对象(上一次渲染的props保存在dom实例中)
    const nextProps = fiber._element.props

    for (const propName in nextProps) {
        //todo  处理class 
        if (propName === 'className' || propName === 'class') {
            handleStyle(propName, dom, nextProps)
        }
        //todo 处理事件
        else if (propName[0] === 'o' && propName[1] === 'n') {
            handleEvent(propName, dom, nextProps)
        }
        // todo 处理其他
        else {
            !isEmpty(nextProps[propName])
                && dom.setAttribute(propName, nextProps[propName]);
        }
    }

    // 更新当前Dom上的props
    updateFiberPropsToDom(dom, nextProps)
}

// todo --------设置事件-----------------
// 如果开启了合成事件系统, 不在dom节点上设置addEventListener,而是直接遍历fiber,从props中捕获事件,一并绑定到root中,模拟冒泡或者捕获执行
// 如果没开启,则直接在这里设置事件到DOM上
function handleEvent(
    propName: string,
    dom: Element,
    nextProps: Object
) {

    // 判断是否使用合成事件系统,使用则不在这里进行设置
    const useSES = global.islzySyntheticEventSystemOpen
    // 大小写处理
    if (propName[2].toLowerCase() === propName[2]) {
        console.warn(`请使用on+大写字母替代${propName},实现与原生区分`)
    }

    // 处理捕获事件 : onClickCapture
    // 删除Capture后缀  删除on前缀 如果使用了capture后缀则在listener中捕获
    let eventName = propName.toLowerCase().replace(/capture$/, '');
    const useCapture = propName !== eventName;
    eventName = eventName.slice(2);

    // 获取dom中的上一个eventHandler,更新为新的
    let prevEventHandler = getFiberCurrentPropsFromDom(dom)[propName]
    // 新handler,绑定为dispach,以便组成合成事件
    let eventHandler = nextProps[propName];

    if (isEmpty(eventHandler)) return
    
    // 删除上一个监听器(更新函数引用)
    if (typeof prevEventHandler === 'function') {
        useSES || dom.removeEventListener(eventName, prevEventHandler, useCapture)
    }
    // 添加一个监听器(更新函数引用)
    if (typeof eventHandler === 'function') {
        useSES || dom.addEventListener(eventName, eventHandler, useCapture)
    } else {
        console.warn(`事件${propName}处理需要传递一个函数`)
    }

}

// todo ----------处理样式---------------
function handleStyle(
    propName: string,
    dom: Element,
    nextProps: Object
) {
    // 可同时使用class和className
    if (propName["class"] && propName["className"]) {
        console.warn("请不要混用属性class和className")
    }

    const className = nextProps[propName]
    dom.setAttribute("class", className);
}