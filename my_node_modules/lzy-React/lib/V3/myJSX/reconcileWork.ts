
import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode, FunctionElementNode } from "../myReactCore/Interface";
import { concurrentWhile, concurrentWhileHook } from '../myReactCore/concurrent'
import { renderWork_sync, renderWithHook } from './renderWork'
import { hasKey } from '../utils/utils'
import { logger } from '../utils/logger';

// 浅比较两个节点是否相同 可复用
function shallowCompareElement(newEle: ElementNode, oldEle: ElementNode) {
  return (
    (newEle?.key === oldEle?.key)
    && (newEle?.tag === oldEle?.tag)
    && (newEle?.key === oldEle?.key))
}

// 同步添加fiber树
function placementFiber(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
  // 创建
  let workInProgressFiber = renderWork_sync(rootElement).fiber

  // 切换$
  if (workInProgressFiber.$fiber !== parentFiber.$fiber) {
    workInProgressFiber = workInProgressFiber.alternate
  }

  // 链接
  workInProgressFiber._parent = parentFiber
  workInProgressFiber.alternate._parent = parentFiber.alternate

  rootElement.fiber = workInProgressFiber
  workInProgressFiber._element = rootElement
  workInProgressFiber.alternate._element = rootElement

  if (prevSibling) {
    const prevSiblingFiber = prevSibling.fiber
    const nextSibling = prevSiblingFiber._sibling

    prevSiblingFiber._sibling = workInProgressFiber
    prevSiblingFiber.alternate._sibling = workInProgressFiber.alternate
    if (nextSibling) {
      workInProgressFiber._sibling = nextSibling
      workInProgressFiber.alternate._sibling = nextSibling.alternate
    }
  }
}

// 将workInProgressFiber从老ele上链接到新ele上,并变更当前全局工作节点
function switchWorkInProgressFiber(newEle: ElementNode, oldEle: ElementNode) {

  const workInProgressFiber = oldEle.fiber
  global.workInprogressFiberNode = workInProgressFiber   // 变更当前工作节点

  newEle.fiber = workInProgressFiber
  workInProgressFiber._element = newEle
  workInProgressFiber.alternate._element = newEle        // 双fiber同时切换到newEle

  workInProgressFiber.effectTag = 'Update'               // 打上更新标记
}

export function reconcileWork_sync(newEle: ElementNode, oldEle: ElementNode): { isSameNode: boolean, newEle: ElementNode } {

  // 新vnode和老vnode进行对比
  const isSameNode = shallowCompareElement(newEle, oldEle)

  if (!isSameNode) return { isSameNode, newEle }

  switchWorkInProgressFiber(newEle, oldEle) // 将wk挂载到newEle上

  //TODO 如果是函数组件, 继续向下执行函数组件(分节点拆分)
  renderWithHook(newEle as FunctionElementNode)

  if (newEle.children && newEle.children.length > 0) {
    let i = 0;
    while (i < newEle.children.length) {
      const newChild = newEle.children[i]
      const oldChild = oldEle.children[i]
      const { isSameNode } = reconcileWork_sync(newChild, oldChild)
      if (!isSameNode) break
      i++
    }


    // 老fiber生成map
    const fiberMap = new Map()
    oldEle.children.forEach((oldChild) => {
      if (hasKey(oldChild)) {
        fiberMap.set(oldChild.key, oldChild.fiber)
      }
    })


    if (i <= newEle.children.length) {
      // 遍历处理后续未处理的newEle节点
      for (let k = i; k < newEle.children.length; k++) {
        let newChildEle = newEle.children[k]
        // map中找到则拿来复用
        if (hasKey(newChildEle) && fiberMap.has(newChildEle.key)) {

          const workInProgressFiber = fiberMap.get(newChildEle.key)
          // 变更当前工作节点
          global.workInprogressFiberNode = workInProgressFiber
          logger.log('复用fiber', workInProgressFiber);
          // 拼接后从map中删除
          fiberMap.delete(newChildEle.key)
        }
        // map中未找到 且有key说明需要添加节点
        else if (hasKey(newChildEle) && !fiberMap.has(newChildEle.key)) {
          const siblingBefore = newEle.children[k - 1]
          logger.log('添加节点', newChildEle, newEle.fiber, siblingBefore);  // 正确
          placementFiber(newChildEle, newEle.fiber, siblingBefore)
        }

        // 其余无key的节点
        else {
          const reIndexNew = newEle.children.length - 1 - k
          const indexOld = oldEle.children.length - 1 - reIndexNew
          const oldChildEle = oldEle.children[indexOld]
          reconcileWork_sync(newChildEle, oldChildEle)
        }
      }

    }



    // 新fiber从map中删除
    newEle.children.forEach((newChild) => {
      fiberMap.delete(newChild.key)
    })
    // 遍历map中剩余的fiber,打上删除tag
    fiberMap.forEach((fiber: FiberNode) => {
      fiber.effectTag = 'Delete'
    })
  }

  return { isSameNode, newEle }
}