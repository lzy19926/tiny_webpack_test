
import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode, FunctionElementNode } from "../myReactCore/Interface";
import { concurrentWhile, concurrentWhileHook } from '../myReactCore/concurrent'
import { isFunctionEle } from './elementType'
import { renderElement, renderWithHook } from './renderWork'
import { hasKey } from '../utils/utils'
import { logger } from '../utils/logger';

// 浅比较两个节点是否相同 可复用
function shallowCompareElement(newEle: ElementNode, oldEle: ElementNode) {
  return (
    (newEle?.key === oldEle?.key)
    && (newEle?.tag === oldEle?.tag)
    && (newEle?.key === oldEle?.key))
}

// 同步添加fiber树
function placementFiber(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
  // 创建
  let workInProgressFiber = reconcileElement(rootElement).fiber

  // 切换$
  if (workInProgressFiber.$fiber !== parentFiber.$fiber) {
    workInProgressFiber = workInProgressFiber.alternate
  }

  // 链接
  workInProgressFiber._parent = parentFiber
  workInProgressFiber.alternate._parent = parentFiber.alternate

  rootElement.fiber = workInProgressFiber
  workInProgressFiber._element = rootElement
  workInProgressFiber.alternate._element = rootElement

  if (prevSibling) {
    const prevSiblingFiber = prevSibling.fiber
    const nextSibling = prevSiblingFiber._sibling

    prevSiblingFiber._sibling = workInProgressFiber
    prevSiblingFiber.alternate._sibling = workInProgressFiber.alternate
    if (nextSibling) {
      workInProgressFiber._sibling = nextSibling
      workInProgressFiber.alternate._sibling = nextSibling.alternate
    }
  }
}

// 同步创建fiber树
function reconcileElement(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
  if (!rootElement) return

  let stack = []
  stack.push({ element: rootElement, parentFiber, prevSibling, })

  while (stack.length > 0) {
    const { element, parentFiber, prevSibling } = stack.pop()
    const prevSiblingFiber = prevSibling?.fiber // 此时siblingFiber已经生成 从element指针中拿出siblingFiber
    const workInProgressFiber = renderElement(element, parentFiber, prevSiblingFiber)

    // 继续执行
    if (element.children && element.children.length > 0) {
      let i = element.children.length - 1
      for (i; i >= 0; i--) {
        stack.push({
          element: element.children[i],
          parentFiber: workInProgressFiber,
          prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
        })
      }
    }
  }

  return rootElement
}

// 将workInProgressFiber从老ele上链接到新ele上,并变更当前全局工作节点
function switchWorkInProgressFiber(newEle: ElementNode, oldEle: ElementNode) {

  const workInProgressFiber = oldEle.fiber
  global.workInprogressFiberNode = workInProgressFiber   // 变更当前工作节点

  newEle.fiber = workInProgressFiber
  workInProgressFiber._element = newEle
  workInProgressFiber.alternate._element = newEle        // 双fiber同时切换到newEle

  workInProgressFiber.effectTag = 'Update'               // 打上更新标记
}

export function updateReconcileElement(newEle: ElementNode, oldEle: ElementNode): { isSameNode: boolean, newEle: ElementNode } {

  // 新vnode和老vnode进行对比
  const isSameNode = shallowCompareElement(newEle, oldEle)

  if (!isSameNode) return { isSameNode, newEle }

  switchWorkInProgressFiber(newEle, oldEle) // 将wk挂载到newEle上

  // 继续向下 组件vnode   挂载props,children和fiber


  renderWithHook(newEle as FunctionElementNode)

  // if (isFunctionEle(newEle)) {
  //   const childElement = (newEle as FunctionElementNode).render.call(undefined, newEle.props, newEle.children, newEle.fiber)
  //   newEle.children = [childElement]
  // }

  if (newEle.children && newEle.children.length > 0) {
    let i = 0;
    while (i < newEle.children.length) {
      const newChild = newEle.children[i]
      const oldChild = oldEle.children[i]
      const { isSameNode } = updateReconcileElement(newChild, oldChild)
      if (!isSameNode) break
      i++
    }


    // 老fiber生成map
    const fiberMap = new Map()
    oldEle.children.forEach((oldChild) => {
      if (hasKey(oldChild)) {
        fiberMap.set(oldChild.key, oldChild.fiber)
      }
    })


    if (i <= newEle.children.length) {
      // 遍历处理后续未处理的newEle节点
      for (let k = i; k < newEle.children.length; k++) {
        let newChildEle = newEle.children[k]
        // map中找到则拿来复用
        if (hasKey(newChildEle) && fiberMap.has(newChildEle.key)) {

          const workInProgressFiber = fiberMap.get(newChildEle.key)
          // 变更当前工作节点
          global.workInprogressFiberNode = workInProgressFiber
          logger.log('复用fiber', workInProgressFiber);
          // 拼接后从map中删除
          fiberMap.delete(newChildEle.key)
        }
        // map中未找到 且有key说明需要添加节点
        else if (hasKey(newChildEle) && !fiberMap.has(newChildEle.key)) {
          const siblingBefore = newEle.children[k - 1]
          logger.log('添加节点', newChildEle, newEle.fiber, siblingBefore);  // 正确
          placementFiber(newChildEle, newEle.fiber, siblingBefore)
        }

        // 其余无key的节点
        else {
          const reIndexNew = newEle.children.length - 1 - k
          const indexOld = oldEle.children.length - 1 - reIndexNew
          const oldChildEle = oldEle.children[indexOld]
          updateReconcileElement(newChildEle, oldChildEle)
        }
      }

    }



    // 新fiber从map中删除
    newEle.children.forEach((newChild) => {
      fiberMap.delete(newChild.key)
    })
    // 遍历map中剩余的fiber,打上删除tag
    fiberMap.forEach((fiber: FiberNode) => {
      fiber.effectTag = 'Delete'
    })
  }

  return { isSameNode, newEle }
}