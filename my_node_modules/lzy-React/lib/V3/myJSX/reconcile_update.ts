
import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode } from "../myReactCore/Interface";
import { concurrentWhile, concurrentWhileHook } from '../myReactCore/concurrent'
import { isFunctionEle } from '../myJSX/elementType'
import { createFiberAndConnect } from './reconcileElement'
import { hasKey } from '../utils/utils'

// 浅比较两个节点是否相同 可复用
function shallowCompareElement(newEle: ElementNode, oldEle: ElementNode) {
    return (
        (newEle?.key === oldEle?.key)
        && (newEle?.tag === oldEle?.tag)
        && (newEle?.key === oldEle?.key))
}

// 同步添加fiber树
function placementFiber(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
    // 创建
    let workInProgressFiber = reconcileElement(rootElement).fiber

    // 切换$
    if (workInProgressFiber.$fiber !== parentFiber.$fiber) {
        workInProgressFiber = workInProgressFiber.alternate
    }

    // 链接
    workInProgressFiber._parent = parentFiber
    workInProgressFiber.alternate._parent = parentFiber.alternate

    rootElement.fiber = workInProgressFiber
    workInProgressFiber._element = rootElement
    workInProgressFiber.alternate._element = rootElement

    if (prevSibling) {
        const prevSiblingFiber = prevSibling.fiber
        const nextSibling = prevSiblingFiber._sibling

        prevSiblingFiber._sibling = workInProgressFiber
        prevSiblingFiber.alternate._sibling = workInProgressFiber.alternate
        if (nextSibling) {
            workInProgressFiber._sibling = nextSibling
            workInProgressFiber.alternate._sibling = nextSibling.alternate
        }
    }
}

// 同步创建fiber树
function reconcileElement(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
    if (!rootElement) return

    let stack = []
    stack.push({ element: rootElement, parentFiber, prevSibling, })

    while (stack.length > 0) {
        const { element, parentFiber, prevSibling } = stack.pop()
        const prevSiblingFiber = prevSibling?.fiber // 此时siblingFiber已经生成 从element指针中拿出siblingFiber
        const workInProgressFiber = createFiberAndConnect(element, parentFiber, prevSiblingFiber)

        // 继续执行
        if (element.children && element.children.length > 0) {
            let i = element.children.length - 1
            for (i; i >= 0; i--) {
                stack.push({
                    element: element.children[i],
                    parentFiber: workInProgressFiber,
                    prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
                })
            }
        }
    }

    return rootElement
}

export function updateReconcileElement(newEle: ElementNode, oldEle: ElementNode): { isSameNode: boolean, newEle: ElementNode } {

    // 新vnode和老vnode进行对比
    const isSameNode = shallowCompareElement(newEle, oldEle)

    if (!isSameNode) return { isSameNode, newEle }

    if (isSameNode) {
        // 直接打标记更新该节点的wk
        const workInProgressFiber = oldEle.fiber
        // 变更当前工作节点
        global.workInprogressFiberNode = workInProgressFiber

        workInProgressFiber.effectTag = 'Update'

        // 链接到当前vnode(双fiber同时链接到newEle)
        newEle.fiber = workInProgressFiber
        workInProgressFiber._element = newEle
        workInProgressFiber.alternate._element = newEle
    }

    // 继续向下 组件vnode   挂载props,children和fiber
    if (isFunctionEle(newEle)) {
        const childElement = newEle.ref.call(undefined, newEle.props, newEle.children, newEle.fiber)
        newEle.children = [childElement]
    }

    if (newEle.children && newEle.children.length > 0) {
        let i = 0;
        while (i < newEle.children.length) {
            const newChild = newEle.children[i]
            const oldChild = oldEle.children[i]
            const { isSameNode } = updateReconcileElement(newChild, oldChild)
            if (!isSameNode) break
            i++
        }


        // 老fiber生成map
        const fiberMap = new Map()
        oldEle.children.forEach((oldChild) => {
            if (hasKey(oldChild)) {
                fiberMap.set(oldChild.key, oldChild.fiber)
            }
        })


        if (i <= newEle.children.length) {
            // 遍历处理后续未处理的newEle节点
            for (let k = i; k < newEle.children.length; k++) {
                let newChildEle = newEle.children[k]
                // map中找到则拿来复用
                if (hasKey(newChildEle) && fiberMap.has(newChildEle.key)) {

                    const workInProgressFiber = fiberMap.get(newChildEle.key)
                    // 变更当前工作节点
                    global.workInprogressFiberNode = workInProgressFiber
                    console.log('复用fiber', workInProgressFiber);
                    // 拼接后从map中删除
                    fiberMap.delete(newChildEle.key)
                }
                // map中未找到 且有key说明需要添加节点
                else if (hasKey(newChildEle) && !fiberMap.has(newChildEle.key)) {
                    const siblingBefore = newEle.children[k - 1]
                    console.log('添加节点', newChildEle, newEle.fiber, siblingBefore);  // 正确
                    placementFiber(newChildEle, newEle.fiber, siblingBefore)
                }

                // 其余无key的节点
                else {
                    const reIndexNew = newEle.children.length - 1 - k
                    const indexOld = oldEle.children.length - 1 - reIndexNew
                    const oldChildEle = oldEle.children[indexOld]
                    updateReconcileElement(newChildEle, oldChildEle)
                }
            }

        }



        // 新fiber从map中删除
        newEle.children.forEach((newChild) => {
            fiberMap.delete(newChild.key)
        })
        // 遍历map中剩余的fiber,打上删除tag
        fiberMap.forEach((fiber: FiberNode) => {
            fiber.effectTag = 'Delete'
        })
    }



    return { isSameNode, newEle }
}