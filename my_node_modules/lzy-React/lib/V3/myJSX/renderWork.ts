import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode, FunctionElementNode } from "../myReactCore/Interface";
import { concurrentWhile, concurrentWhileHook } from '../myReactCore/concurrent'
import { isFunctionEle, isContextProviderEle, isDomEle, isTextEle, isForwardRefEle, getElementType, ElementType, ET } from './elementType'

import { logger } from '../utils/logger';

type RenderElementEntry = {
  elementNode: ElementNode,
  workInProgressFiber: FiberNode,
  parentFiber: FiberNode,
  prevSibling: FiberNode
}

// --创建基础Fiber节点
function createBaseFiberNode(elementNode: ElementNode, parentFiber: FiberNode) {
  // 创建newFiber
  let newFiberNode = new FiberNode('mount', '$1')

  // 切换当前工作fiber
  global.workInprogressFiberNode = newFiberNode

  // 给fiber赋值 并链接parent
  newFiberNode._parent = parentFiber
  newFiberNode.tag = elementNode.tag
  newFiberNode._element = elementNode
  newFiberNode.effectTag = 'Placement'
  elementNode.fiber = newFiberNode

  return newFiberNode
}
// 创建单个alt
function createAlternate(currentFiber: FiberNode): FiberNode {
  let alternateFiber = new FiberNode('mount', '$2')

  //! 将一些属性复制给workInProgress
  alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer
  alternateFiber.updateQueue = currentFiber.updateQueue
  alternateFiber.hookIndex = currentFiber.hookIndex
  alternateFiber.memorizedState = currentFiber.memorizedState
  alternateFiber.nodeType = currentFiber.nodeType
  alternateFiber.effectTag = currentFiber.effectTag
  alternateFiber.tag = currentFiber.tag
  alternateFiber.text = currentFiber.text
  alternateFiber.stateNode = currentFiber.stateNode
  alternateFiber._element = currentFiber._element
  //! 链接两个fiber
  alternateFiber.alternate = currentFiber
  currentFiber.alternate = alternateFiber
  //! 链接parent
  if (currentFiber._parent) {
    alternateFiber._parent = currentFiber._parent.alternate
    currentFiber._parent.alternate = alternateFiber._parent
  }


  return alternateFiber
}
// --链接父,兄fiber节点
function linkParentAndSiblingFiberNode(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  if (parentFiber) {
    workInProgressFiber._parent = parentFiber
    workInProgressFiber.alternate._parent = parentFiber?.alternate
  }

  if (prevSibling) {
    prevSibling._sibling = workInProgressFiber
    prevSibling.alternate._sibling = workInProgressFiber.alternate
  }
  else if (parentFiber && !prevSibling) {
    parentFiber._child = workInProgressFiber
    parentFiber.alternate._child = workInProgressFiber.alternate
  }

  return workInProgressFiber
}
// --执行带有hook的函数式组件
function renderWithHook(elementNode: FunctionElementNode) {





  let childElement: ElementNode;
  // 执行函数组件
  if (isFunctionEle(elementNode)) {
    childElement = elementNode.render.call(
      undefined,
      elementNode.props,
      elementNode.children,
      elementNode.fiber
    )
  }
  // 执行forwardRef函数组件(将ref作为二号参数注入)
  else if (isForwardRefEle(elementNode)) {
    childElement = (elementNode as FunctionElementNode)
      .render.call(
        undefined,
        elementNode.props,
        elementNode.ref,
        elementNode.children,
        elementNode.fiber
      )
  }
  elementNode.children = [childElement]
}

function mountFunctionComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'FunctionComponent'
  workInProgressFiber.stateNode = elementNode.ref

  // 执行带有hook的函数式组件
  renderWithHook(elementNode as FunctionElementNode)

  return workInProgressFiber
}
function mountHostComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'HostComponent'


  return workInProgressFiber
}
function mountHostText(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'HostText'
  workInProgressFiber.text = elementNode.text

  return workInProgressFiber
}
function mountContextProvider(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'ContextProvider'

  return workInProgressFiber
}
function mountForwardRef(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'ForwardRef'
  workInProgressFiber.stateNode = elementNode.ref

  // 执行带有hook的函数式组件
  renderWithHook(elementNode as FunctionElementNode)

  return workInProgressFiber
}
function mountMemoComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'MemoComponent'

  return workInProgressFiber
}
function warnUnknownComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'UnknownType'
  logger.warn("创建了未知类型的fiber节点")
}

//!------通过domContainer创建rootFiber
export function createContainerFiber(domContainer: HTMLElement) {
  let newFiberNode = new FiberNode('mount', '$1')
  global.workInprogressFiberNode = newFiberNode

  newFiberNode.tag = domContainer.tagName
  newFiberNode.nodeType = 'AppNode'
  newFiberNode.stateNode = domContainer

  createAlternate(newFiberNode)

  newFiberNode.fiberFlags = 'update'
  newFiberNode.alternate.fiberFlags = 'update'

  return newFiberNode
}

// 处理单个element节点,创建fiber,alternate并链接(并生成子elements)
export function renderElement(elementNode: ElementNode, parentFiber: FiberNode, prevSibling: FiberNode) {
  const elementType = getElementType(elementNode) as ElementType
  const workInProgressFiber = createBaseFiberNode(elementNode, undefined)
  const entry: RenderElementEntry = {
    elementNode,
    workInProgressFiber,
    parentFiber,
    prevSibling
  }

  switch (elementType) {
    case ET.FUNCTION_COMPONENT: mountFunctionComponent(entry)
      break;
    case ET.HOST_COMPONENT: mountHostComponent(entry)
      break;
    case ET.HOST_TEXT: mountHostText(entry)
      break;
    case ET.CONTEXT__PROVIDER: mountContextProvider(entry)
      break;
    case ET.FORWARD_REF_TYPE: mountForwardRef(entry)
      break;
    case ET.MEMO_TYPE: mountMemoComponent(entry)
      break;
    default: warnUnknownComponent(entry)
      break;
  }
  //-- 创建alt(顺序不能乱)
  createAlternate(workInProgressFiber)

  linkParentAndSiblingFiberNode(entry)

  // 更改状态
  workInProgressFiber.fiberFlags = 'update'
  workInProgressFiber.alternate.fiberFlags = 'update'

  return workInProgressFiber
}

//! ---- 通过rootElement,rootFiber逐步构建element树和fiber二叉树
// (使用栈算法分片执行)
export function renderWork_concurrent(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
  if (!rootElement) return

  let stack = []
  stack.push({ element: rootElement, parentFiber, prevSibling, })

  //! 栈算法分片执行
  const getCondition = () => stack.length > 0
  concurrentWhile(getCondition, () => {

    const { element, parentFiber, prevSibling } = stack.pop()
    const prevSiblingFiber = prevSibling?.fiber // 此时siblingFiber已经生成 从element指针中拿出siblingFiber

    const workInProgressFiber = renderElement(element, parentFiber, prevSiblingFiber)//! 关键步骤

    // 继续执行
    if (element.children && element.children.length > 0) {
      let i = element.children.length - 1
      for (i; i >= 0; i--) {
        stack.push({
          element: element.children[i],
          parentFiber: workInProgressFiber,
          prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
        })
      }
    }

    // 执行结束回调
    if (!getCondition()) {
      const cb = concurrentWhileHook.afterFirstReconcile
      if (typeof cb === 'function') {
        cb()
      }
    }
  })

  return rootElement
}
