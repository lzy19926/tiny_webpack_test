import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode, FunctionElementNode } from "../myReactCore/Interface";
import { concurrentWhile, concurrentWhileHook } from '../myReactCore/concurrent'
import { isFunctionEle, isContextProviderEle, isDomEle, isTextEle, isForwardRefEle, getElementType, ElementType, ET } from '../myJSX/elementType'

import { logger } from '../utils/logger';

type RenderElementEntry = {
  elementNode: ElementNode,
  workInProgressFiber: FiberNode,
  parentFiber: FiberNode,
  prevSibling: FiberNode
}

//!------通过domContainer创建rootFiber
export function createContainerFiber(domContainer: HTMLElement) {
  let newFiberNode = new FiberNode('mount', '$1')
  global.workInprogressFiberNode = newFiberNode

  newFiberNode.tag = domContainer.tagName
  newFiberNode.nodeType = 'AppNode'
  newFiberNode.stateNode = domContainer

  createAlternate(newFiberNode)

  newFiberNode.fiberFlags = 'update'
  newFiberNode.alternate.fiberFlags = 'update'

  return newFiberNode
}

//!------ 创建单个fiber节点
function createFiber(elementNode: ElementNode, parentFiber: FiberNode) {
  // 创建newFiber
  let newFiberNode = new FiberNode('mount', '$1')

  // 切换当前工作fiber
  global.workInprogressFiberNode = newFiberNode

  // 给fiber赋值 并链接parent
  newFiberNode._parent = parentFiber
  newFiberNode.tag = elementNode.tag
  newFiberNode._element = elementNode
  newFiberNode.effectTag = 'Placement'
  elementNode.fiber = newFiberNode

  // 解析无需渲染的context等节点
  if (isContextProviderEle(elementNode)) {
    newFiberNode.nodeType = 'ContextProvider'
  }
  //如果tag大写 解析为FC组件节点 重新生成element
  else if (isFunctionEle(elementNode)) {
    newFiberNode.nodeType = 'FunctionComponent'
    newFiberNode.stateNode = elementNode.ref
  }
  //解析为forwardRef类型FC节点 重新生成element
  else if (isForwardRefEle(elementNode)) {
    newFiberNode.nodeType = 'ForwardRef'
    newFiberNode.stateNode = elementNode.ref
  }
  //解析为text节点
  else if (isTextEle(elementNode)) {
    newFiberNode.nodeType = 'HostText'
    newFiberNode.text = elementNode.text
  }
  //解析为普通dom节点
  else if (isDomEle(elementNode)) {
    newFiberNode.nodeType = 'HostComponent'
  }
  //TODO 其他
  else {
    newFiberNode.nodeType = 'UnknownType'
    logger.warn("创建了未知类型的fiber节点")
  }

  return newFiberNode
}

// 创建单个alt
function createAlternate(currentFiber: FiberNode): FiberNode {
  let alternateFiber = new FiberNode('mount', '$2')

  //! 将一些属性复制给workInProgress
  alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer
  alternateFiber.updateQueue = currentFiber.updateQueue
  alternateFiber.hookIndex = currentFiber.hookIndex
  alternateFiber.memorizedState = currentFiber.memorizedState
  alternateFiber.nodeType = currentFiber.nodeType
  alternateFiber.effectTag = currentFiber.effectTag
  alternateFiber.tag = currentFiber.tag
  alternateFiber.text = currentFiber.text
  alternateFiber.stateNode = currentFiber.stateNode
  alternateFiber._element = currentFiber._element
  //! 链接两个fiber
  alternateFiber.alternate = currentFiber
  currentFiber.alternate = alternateFiber
  //! 链接parent
  if (currentFiber._parent) {
    alternateFiber._parent = currentFiber._parent.alternate
    currentFiber._parent.alternate = alternateFiber._parent
  }


  return alternateFiber
}

// 遍历到的单个节点处理  创建并链接节点 同时创建alt
export function createFiberAndConnect(element: ElementNode, parentFiber: FiberNode, prevSibling: FiberNode) {

  //--创建
  let workInProgressFiber = createFiber(element, undefined)

  // 执行函数组件函数
  if (isFunctionEle(element)) {
    const childElement = (element as FunctionElementNode)
      .render.call(
        undefined,
        element.props,
        element.children,
        element.fiber
      )
    element.children = [childElement]
  }
  // 执行forwardRef函数组件(将ref作为二号参数注入)
  if (isForwardRefEle(element)) {
    const childElement = (element as FunctionElementNode)
      .render.call(
        undefined,
        element.props,
        element.ref,
        element.children,
        element.fiber
      )
    element.children = [childElement]
  }

  //-- 创建alt(顺序不能乱)
  const workInProgressFiber_alt = createAlternate(workInProgressFiber)

  // --链接
  if (parentFiber) {
    workInProgressFiber._parent = parentFiber
    workInProgressFiber.alternate._parent = parentFiber?.alternate
  }

  if (prevSibling) {
    prevSibling._sibling = workInProgressFiber
    prevSibling.alternate._sibling = workInProgressFiber.alternate
  }
  else if (parentFiber && !prevSibling) {
    parentFiber._child = workInProgressFiber
    parentFiber.alternate._child = workInProgressFiber.alternate
  }


  // 更改状态
  workInProgressFiber.fiberFlags = 'update'
  workInProgressFiber.alternate.fiberFlags = 'update'

  return workInProgressFiber
}


// 处理单个element节点,创建fiber,alternate并链接(并生成子elements)
function renderElement(elementNode: ElementNode, parentFiber: FiberNode, prevSibling: FiberNode) {
  const elementType = getElementType(elementNode) as ElementType
  const workInProgressFiber = createBaseFiberNode(elementNode, undefined)
  const entry: RenderElementEntry = {
    elementNode,
    workInProgressFiber,
    parentFiber,
    prevSibling
  }

  switch (elementType) {
    case ET.FUNCTION_COMPONENT:
      mountFunctionComponent(entry)
      break;
    case ET.HOST_COMPONENT:
      mountHostComponent(entry)
      break;
    case ET.HOST_TEXT:
      mountHostText(entry)
      break;
    case ET.CONTEXT__PROVIDER:
      mountContextProvider(entry)
      break;
    case ET.FORWARD_REF_TYPE:
      mountForwardRef(entry)
      break;
    case ET.MEMO_TYPE:
      mountMemoComponent(entry)
      break;
    default:
      warnUnknownComponent(entry)
      break;
  }

  linkParentAndSiblingFiberNode(entry)

  // 更改状态
  workInProgressFiber.fiberFlags = 'update'
  workInProgressFiber.alternate.fiberFlags = 'update'

  return workInProgressFiber
}

// --创建基础Fiber节点
function createBaseFiberNode(elementNode: ElementNode, parentFiber: FiberNode) {
  // 创建newFiber
  let newFiberNode = new FiberNode('mount', '$1')

  // 切换当前工作fiber
  global.workInprogressFiberNode = newFiberNode

  // 给fiber赋值 并链接parent
  newFiberNode._parent = parentFiber
  newFiberNode.tag = elementNode.tag
  newFiberNode._element = elementNode
  newFiberNode.effectTag = 'Placement'
  elementNode.fiber = newFiberNode

  return newFiberNode
}
// --链接父,兄fiber节点
function linkParentAndSiblingFiberNode(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  if (parentFiber) {
    workInProgressFiber._parent = parentFiber
    workInProgressFiber.alternate._parent = parentFiber?.alternate
  }

  if (prevSibling) {
    prevSibling._sibling = workInProgressFiber
    prevSibling.alternate._sibling = workInProgressFiber.alternate
  }
  else if (parentFiber && !prevSibling) {
    parentFiber._child = workInProgressFiber
    parentFiber.alternate._child = workInProgressFiber.alternate
  }

  return workInProgressFiber
}
function mountFunctionComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'FunctionComponent'
  workInProgressFiber.stateNode = elementNode.ref

  // 执行函数组件函数
  const childElement = (elementNode as FunctionElementNode)
    .render.call(
      undefined,
      elementNode.props,
      elementNode.children,
      elementNode.fiber
    )
  elementNode.children = [childElement]

  return workInProgressFiber
}
function mountHostComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'HostComponent'


  return workInProgressFiber
}
function mountHostText(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'HostText'
  workInProgressFiber.text = elementNode.text

  return workInProgressFiber
}
function mountContextProvider(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'ContextProvider'

  return workInProgressFiber
}
function mountForwardRef(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'ForwardRef'
  workInProgressFiber.stateNode = elementNode.ref

  // 执行forwardRef函数组件(将ref作为二号参数注入)
  const childElement = (elementNode as FunctionElementNode)
    .render.call(
      undefined,
      elementNode.props,
      elementNode.ref,
      elementNode.children,
      elementNode.fiber
    )
  elementNode.children = [childElement]


  return workInProgressFiber
}
function mountMemoComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'MemoComponent'

  return workInProgressFiber
}
function warnUnknownComponent(entry: RenderElementEntry) {
  const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry

  workInProgressFiber.nodeType = 'UnknownType'
  logger.warn("创建了未知类型的fiber节点")
}


//! ---- 通过rootElement,rootFiber逐步构建element树和fiber二叉树
// (使用栈算法分片执行)
export function renderWork_concurrent(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
  if (!rootElement) return

  let stack = []
  stack.push({ element: rootElement, parentFiber, prevSibling, })

  //! 栈算法分片执行
  const getCondition = () => stack.length > 0
  concurrentWhile(getCondition, () => {

    const { element, parentFiber, prevSibling } = stack.pop()
    const prevSiblingFiber = prevSibling?.fiber // 此时siblingFiber已经生成 从element指针中拿出siblingFiber

    const workInProgressFiber = createFiberAndConnect(element, parentFiber, prevSiblingFiber)//! 关键步骤

    // 继续执行
    if (element.children && element.children.length > 0) {
      let i = element.children.length - 1
      for (i; i >= 0; i--) {
        stack.push({
          element: element.children[i],
          parentFiber: workInProgressFiber,
          prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
        })
      }
    }

    // 执行结束回调
    if (!getCondition()) {
      const cb = concurrentWhileHook.afterFirstReconcile
      if (typeof cb === 'function') {
        cb()
      }
    }
  })

  return rootElement
}