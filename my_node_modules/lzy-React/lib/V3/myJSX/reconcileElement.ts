import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode, TextElementNode } from "../myReactCore/Interface";
import { concurrentWhile, concurrentWhileHook } from '../myReactCore/concurrent'

//!------ 创建单个fiber节点
function createFiber(elementNode: ElementNode | TextElementNode, parentFiber: FiberNode) {
    // 创建newFiber
    let newFiberNode = new FiberNode('mount', '$1')

    // 切换当前工作fiber
    global.workInprogressFiberNode = newFiberNode

    // 给fiber赋值 并链接parent
    newFiberNode._parent = parentFiber
    newFiberNode.tag = elementNode.tag
    newFiberNode._element = elementNode
    newFiberNode.effectTag = 'Placement'
    elementNode.fiber = newFiberNode

    //如果tag大写 解析为FC组件节点 重新生成element  挂载props
    if (elementNode.tag[0] === elementNode.tag[0].toUpperCase()) {
        newFiberNode.nodeType = 'FunctionComponent'
        newFiberNode.stateNode = elementNode.ref
    }
    //解析为text节点
    else if (elementNode.tag === 'text') {
        newFiberNode.nodeType = 'HostText'
        newFiberNode.text = elementNode.text
    }
    //解析为普通dom节点
    else {
        newFiberNode.nodeType = 'HostComponent'
    }

    return newFiberNode
}

// 创建单个alt
function createAlternate(currentFiber: FiberNode): FiberNode {
    let alternateFiber = new FiberNode('mount', '$2')

    //! 将一些属性复制给workInProgress
    alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer
    alternateFiber.updateQueue = currentFiber.updateQueue
    alternateFiber.hookIndex = currentFiber.hookIndex
    alternateFiber.memorizedState = currentFiber.memorizedState
    alternateFiber.nodeType = currentFiber.nodeType
    alternateFiber.effectTag = currentFiber.effectTag
    alternateFiber.tag = currentFiber.tag
    alternateFiber.text = currentFiber.text
    alternateFiber.stateNode = currentFiber.stateNode
    alternateFiber._element = currentFiber._element
    //! 链接两个fiber
    alternateFiber.alternate = currentFiber
    currentFiber.alternate = alternateFiber
    //! 链接parent
    if (currentFiber._parent) {
        alternateFiber._parent = currentFiber._parent.alternate
        currentFiber._parent.alternate = alternateFiber._parent
    }


    return alternateFiber
}

// 遍历到的单个节点处理  创建并链接节点 同时创建alt
export function createFiberAndConnect(element: ElementNode, parentFiber: FiberNode, prevSibling: FiberNode) {

    //--创建
    let workInProgressFiber = createFiber(element, undefined)

    // 组件vnode   挂载props 
    if (element.tag[0] === element.tag[0].toUpperCase()) {
        const childElement = element.ref.call(undefined, element.props)
        element.children = [childElement]
    }

    //-- 创建alt(顺序不能乱)
    const workInProgressFiber_alt = createAlternate(workInProgressFiber)

    // --链接
    if (parentFiber) {
        workInProgressFiber._parent = parentFiber
        workInProgressFiber.alternate._parent = parentFiber?.alternate
    }

    if (prevSibling) {
        prevSibling._sibling = workInProgressFiber
        prevSibling.alternate._sibling = workInProgressFiber.alternate
    }
    else if (parentFiber && !prevSibling) {
        parentFiber._child = workInProgressFiber
        parentFiber.alternate._child = workInProgressFiber.alternate
    }


    // 更改状态
    workInProgressFiber.fiberFlags = 'update'
    workInProgressFiber.alternate.fiberFlags = 'update'

    return workInProgressFiber
}

//! ---- 通过rootElement创建二叉fiber树(切片)
// 通过传入parent,siblingBefore节点创建二叉树
// 通过栈将普通树的递归遍历转换为while循环, 再用切片while执行   
export function reconcileElement_concurrent(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
    if (!rootElement) return

    let stack = []
    stack.push({ element: rootElement, parentFiber, prevSibling, })

    //! 栈算法分片执行
    const getCondition = () => stack.length > 0
    concurrentWhile(getCondition, () => {

        const { element, parentFiber, prevSibling } = stack.pop()
        const prevSiblingFiber = prevSibling?.fiber // 此时siblingFiber已经生成 从element指针中拿出siblingFiber
        const workInProgressFiber = createFiberAndConnect(element, parentFiber, prevSiblingFiber)

        // 继续执行
        if (element.children && element.children.length > 0) {
            let i = element.children.length - 1
            for (i; i >= 0; i--) {
                stack.push({
                    element: element.children[i],
                    parentFiber: workInProgressFiber,
                    prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
                })
            }
        }

        // 执行结束回调
        if (!getCondition()) {
            concurrentWhileHook.afterFirstReconcile()
        }
    })

    return rootElement
}