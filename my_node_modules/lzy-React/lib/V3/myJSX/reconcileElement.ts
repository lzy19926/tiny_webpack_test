import { FiberNode, global } from '../myReactCore/GlobalFiber'
import { ElementNode } from "../myReactCore/Interface";
import { concurrentWhile, concurrentWhileHook } from '../myReactCore/concurrent'
import { isFunctionEle, isContextProviderEle, isDomEle, isTextEle } from '../myJSX/elementType'
import { logger } from '../utils/logger';
//!------通过domContainer创建rootFiber
export function createContainerFiber(domContainer: HTMLElement) {
  let newFiberNode = new FiberNode('mount', '$1')
  global.workInprogressFiberNode = newFiberNode

  newFiberNode.tag = domContainer.tagName
  newFiberNode.nodeType = 'AppNode'
  newFiberNode.stateNode = domContainer

  createAlternate(newFiberNode)

  newFiberNode.fiberFlags = 'update'
  newFiberNode.alternate.fiberFlags = 'update'

  return newFiberNode
}


//!------ 创建单个fiber节点
function createFiber(elementNode: ElementNode, parentFiber: FiberNode) {
  // 创建newFiber
  let newFiberNode = new FiberNode('mount', '$1')

  // 切换当前工作fiber
  global.workInprogressFiberNode = newFiberNode

  // 给fiber赋值 并链接parent
  newFiberNode._parent = parentFiber
  newFiberNode.tag = elementNode.tag
  newFiberNode._element = elementNode
  newFiberNode.effectTag = 'Placement'
  elementNode.fiber = newFiberNode

  // 解析无需渲染的context等节点
  if (isContextProviderEle(elementNode)) {
    newFiberNode.nodeType = 'ContextProvider'
  }
  //如果tag大写 解析为FC组件节点 重新生成element
  else if (isFunctionEle(elementNode)) {
    newFiberNode.nodeType = 'FunctionComponent'
    newFiberNode.stateNode = elementNode.ref
  }
  //解析为text节点
  else if (isTextEle(elementNode)) {
    newFiberNode.nodeType = 'HostText'
    newFiberNode.text = elementNode.text
  }
  //解析为普通dom节点
  else if (isDomEle(elementNode)) {
    newFiberNode.nodeType = 'HostComponent'
  }
  //TODO 其他
  else {
    newFiberNode.nodeType = 'UnknownType'
    logger.warn("创建了未知类型的fiber节点")
  }

  return newFiberNode
}

// 创建单个alt
function createAlternate(currentFiber: FiberNode): FiberNode {
  let alternateFiber = new FiberNode('mount', '$2')

  //! 将一些属性复制给workInProgress
  alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer
  alternateFiber.updateQueue = currentFiber.updateQueue
  alternateFiber.hookIndex = currentFiber.hookIndex
  alternateFiber.memorizedState = currentFiber.memorizedState
  alternateFiber.nodeType = currentFiber.nodeType
  alternateFiber.effectTag = currentFiber.effectTag
  alternateFiber.tag = currentFiber.tag
  alternateFiber.text = currentFiber.text
  alternateFiber.stateNode = currentFiber.stateNode
  alternateFiber._element = currentFiber._element
  //! 链接两个fiber
  alternateFiber.alternate = currentFiber
  currentFiber.alternate = alternateFiber
  //! 链接parent
  if (currentFiber._parent) {
    alternateFiber._parent = currentFiber._parent.alternate
    currentFiber._parent.alternate = alternateFiber._parent
  }


  return alternateFiber
}

// 遍历到的单个节点处理  创建并链接节点 同时创建alt
export function createFiberAndConnect(element: ElementNode, parentFiber: FiberNode, prevSibling: FiberNode) {

  //--创建
  let workInProgressFiber = createFiber(element, undefined)

  // 组件vnode   挂载props children和对应fiber
  if (isFunctionEle(element)) {
    const childElement = element.ref.call(undefined, element.props, element.children, element.fiber)
    element.children = [childElement]
  }

  //-- 创建alt(顺序不能乱)
  const workInProgressFiber_alt = createAlternate(workInProgressFiber)

  // --链接
  if (parentFiber) {
    workInProgressFiber._parent = parentFiber
    workInProgressFiber.alternate._parent = parentFiber?.alternate
  }

  if (prevSibling) {
    prevSibling._sibling = workInProgressFiber
    prevSibling.alternate._sibling = workInProgressFiber.alternate
  }
  else if (parentFiber && !prevSibling) {
    parentFiber._child = workInProgressFiber
    parentFiber.alternate._child = workInProgressFiber.alternate
  }


  // 更改状态
  workInProgressFiber.fiberFlags = 'update'
  workInProgressFiber.alternate.fiberFlags = 'update'

  return workInProgressFiber
}

//! ---- 通过rootElement创建二叉fiber树(切片)
// 通过传入parent,siblingBefore节点创建二叉树
// 通过栈将普通树的递归遍历转换为while循环, 再用切片while执行
export function reconcileElement_concurrent(rootElement: ElementNode, parentFiber?: FiberNode, prevSibling?: ElementNode) {
  if (!rootElement) return

  let stack = []
  stack.push({ element: rootElement, parentFiber, prevSibling, })

  //! 栈算法分片执行
  const getCondition = () => stack.length > 0
  concurrentWhile(getCondition, () => {

    const { element, parentFiber, prevSibling } = stack.pop()
    const prevSiblingFiber = prevSibling?.fiber // 此时siblingFiber已经生成 从element指针中拿出siblingFiber

    const workInProgressFiber = createFiberAndConnect(element, parentFiber, prevSiblingFiber)//! 关键步骤

    // 继续执行
    if (element.children && element.children.length > 0) {
      let i = element.children.length - 1
      for (i; i >= 0; i--) {
        stack.push({
          element: element.children[i],
          parentFiber: workInProgressFiber,
          prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
        })
      }
    }

    // 执行结束回调
    if (!getCondition()) {
      const cb = concurrentWhileHook.afterFirstReconcile
      if (typeof cb === 'function') {
        cb()
      }
    }
  })

  return rootElement
}