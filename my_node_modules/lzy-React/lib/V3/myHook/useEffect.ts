import { Effect, UseEffectHook } from '../myReactCore/Interface'
import { global } from '../myReactCore/GlobalFiber'
import { getCurrentFiberHook } from '../utils/utils'
import { logger } from '../utils/logger'


//! --------创建一个Hook 形成环链表 添加到hook队列--------------
function mountWorkInProgressHook() {
  const fiber = global.workInprogressFiberNode//! 测试

  //todo 新建一个hook
  const newHook: UseEffectHook = {
    index: 0,
    memorizedState: null,
    hookFlags: 'mount',
    next: null
  }

  // 添加Hook进单向链表
  if (fiber.memorizedState !== null) {
    const lastHook = fiber.memorizedState
    newHook.index = lastHook.index + 1
    newHook.next = lastHook
    fiber.memorizedState = newHook
  }

  //接入hook到fiber上
  fiber.memorizedState = newHook
  //接入hook到workProgress
  global.workInProgressHook.currentHook = newHook


  return newHook
}

//! ------浅比较前后deps是否发生变化-------------------
function shallowCompareDeps(nextDeps: any[], prevDeps: any[]) {

  logger.log('前后dep对比', prevDeps, nextDeps);

  // 选取最大的lenght
  const length = nextDeps.length > prevDeps.length ? nextDeps.length : prevDeps.length
  let res = true
  for (let i = 0; i < length; i++) {
    if (nextDeps[i] !== prevDeps[i])
      return res = false
  }
  return res
}

//! --------pushEffect创建/增加Effects更新链表---------------
function pushEffect(tag: string, create: Function, destroy: any, deps: any[] | null) {
  const fiber = global.workInprogressFiberNode//! 测试

  // 创建Effect
  const effect: Effect = {
    tag,
    create,
    destroy,
    deps,
    next: null
  }

  //todo 如果Hook上没有更新链表  创建更新链表  如果有则插入一个effect到更新环链表尾部
  const updateQueue: { lastEffect: Effect | null } = { lastEffect: null }

  if (fiber.updateQueue === null) {
    updateQueue.lastEffect = effect.next = effect // 自身形成环状链表
    //更新fiber上的updateQueue环链表
    fiber.updateQueue = updateQueue
  } else {
    const lastEffect = fiber.updateQueue.lastEffect

    if (lastEffect === null) {//todo 有链表结构但是链表为空
      updateQueue.lastEffect = effect.next = effect // 自身形成环状链表

    } else { // todo 插入effect到环链表尾端
      const firstEffect = lastEffect.next
      lastEffect.next = effect
      effect.next = firstEffect
      updateQueue.lastEffect = effect
      //更新fiber上的updateQueue环链表
      fiber.updateQueue = updateQueue
    }
  }

  //todo 返回这个Effect 会被赋值给hook.memorizedState(最后一次更新的状态)
  return effect
}

//! -------mountEffect(useEffect第一次执行)-------------
function mountEffect(create: Function, deps: any[] | null) {

  const fiber = global.workInprogressFiberNode
  const hookFlag = fiber.fiberFlag

  // mount时创建Hook 成为fiber.memorizedState上的一项Hook (单向链表)
  // 判断是否传入deps 不同时机执行useEffect
  const hook = mountWorkInProgressHook()
  const nextDeps = deps === undefined ? null : deps

  // 根据deps传入不同的情况  实现useEffect的不同使用
  // 此时memorizedState保存的就是最后更新的Effect数据(第一次destroy为undefined)
  if (nextDeps === null) {
    hook.memorizedState = pushEffect('nullDeps', create, undefined, nextDeps)
  } else if (nextDeps.length === 0) {
    hook.memorizedState = pushEffect('noDeps', create, undefined, nextDeps)
  } else {
    hook.memorizedState = pushEffect('depNoChange', create, undefined, nextDeps)
  }



  hook.hookFlags = 'update' // 更新状态
}

//! -------updateEffect(useEffect后续更新)-------------
function updateEffect(create: Function, deps: any[] | null) {
  const fiber = global.workInprogressFiberNode
  const hookFlag = fiber.fiberFlag

  // update时找到当前hook
  const currentHook = getCurrentFiberHook(fiber)

  // 判断是否传入deps 不同时机执行useEffect
  // 如果有currentHook 获得上一次执行create返回的的销毁函数
  if (currentHook !== null) {
    // 找到上一次执行的effect,并取出destroy函数
    // update时从上一次的Effect中取出销毁函数(在commit阶段执行create函数并赋值了destroy)
    const nextDeps = deps === undefined ? null : deps
    const prevEffect = currentHook.memorizedState
    const destroy = prevEffect.destroy
    const prevDeps = prevEffect.deps


    // 根据deps不同推入不同的effect
    // 如果deps发生改变  commit时这个Effects才会被执行  (执行的最后一个effect要被赋值给memorizedState)
    if (nextDeps === null) {
      pushEffect('nullDeps', create, undefined, nextDeps)
    } else {
      if (shallowCompareDeps(nextDeps, prevDeps)) {// 浅比较前后两次deps
        currentHook.memorizedState =
          pushEffect('depChanged', create, destroy, nextDeps)
      } else {
        pushEffect('depNoChange', create, destroy, nextDeps)
      }

    }
  }
}


export { mountEffect, updateEffect }