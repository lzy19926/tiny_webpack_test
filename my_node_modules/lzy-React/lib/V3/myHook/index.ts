import { mountState, updateState } from './useState'
import { mountEffect, updateEffect } from './useEffect'
import { mountRef } from './useRef'
import { mountContext, ReactContext } from './useContext'
import { mountImperativeHandle } from './useImperativeHandle'


// 全局的hookDispatcher, 会根据hook的状态切换是mount还是update的Hook
const ReactCurrentDispatcher = {
  current: null,
};

// hook分为两种,mount和update, 在执行时会根据函数组件fiber类型获取不同的hookDispatcher,执行不同的hook
const HooksDispatcherOnMount = {
  useState: mountState,
  useEffect: mountEffect,
  useContext: mountContext,
  useRef: mountRef,
  useImperativeHandle: mountImperativeHandle
}

const HooksDispatcherOnUpdate = {
  useState: updateState,
  useEffect: updateEffect,
  // (暂时)同mount逻辑相同的hooks
  useContext: mountContext,
  useRef: mountRef,
  useImperativeHandle: mountImperativeHandle
}

// 获取当前的dispatcher
export function resolveDispatcher() {
  const dispatcher = ReactCurrentDispatcher.current

  if (dispatcher === null) {
    console.error("Invalid hook call. Hook只能在函数组件中使用, 未正确挂载hookDsipatcher")
  }

  return dispatcher
}
// 根据fiber状态切换钩子类型
export function switchHooksDispatcher(fiberFlag: "mount" | "update") {
  ReactCurrentDispatcher.current =
    fiberFlag === "mount"
      ? HooksDispatcherOnMount
      : HooksDispatcherOnUpdate
}


/*******************************************************************************************
* Hooks
******************************************************************************************/
export function myUseState(initialState: any) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useState(initialState);
}

export function myUseEffect(create: Function, deps: any[] | null) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useEffect(create, deps);
}

export function myUseContext(context: ReactContext) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useContext(context);
}

export function myUseRef(initialRef: any) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useRef(initialRef);
}

export function myUseImperativeHandle(ref: Function | { current: any }, create: Function, deps: any[]) {
  const dispatcher = resolveDispatcher();
  return dispatcher.useImperativeHandle(ref, create, deps);
}