import { logger } from "../utils/logger";
import { myUseEffect } from './index'

/*******************************************************************************************
 * myUseImperativeHandle的核心逻辑
 * 执行传入的create函数,生成instance挂载到ref.current上(此时已经给dom绑定了ref)
 * 返回一个destroy函数, 删除ref.current,
 * *****************************************************************************************/
//TODO 注意,执行这个create函数时,ref已经被赋值,故应该是使用useLayoutEffect实现
//TODO2 当前为dom节点绑定ref是在layoutMutation阶段实现,应将其挪到commit mutation阶段
//使用useEffect会导致执行此函数时ref内还未挂载dom
function myUseImperativeHandleImpl(ref: Function | { current: any }, create: Function) {
  const instance = create()

  if (typeof ref === 'function') {
    ref(instance)
    return () => {
      ref(null)
    }
  } else {
    ref.current = instance
    return () => {
      ref.current = null
    }
  }
}

/*******************************************************************************************
 * 该Hook的复用useEffect的逻辑, 通过effect队列执行create/destroy函数,并在dep变更时重新执行
 * 将myUseImperativeHandleImpl作为create函数执行,返回destroy函数
 * *****************************************************************************************/
export function myUseImperativeHandle(ref: Function | { current: any }, create: Function, deps: any[]) {

  if (typeof create !== 'function') {
    return logger.error('myUseImperativeHandle()的二号参数应当是一个函数');
  }
  if (ref === null && ref === undefined) {
    return logger.log('myUseImperativeHandle()未接收到ref')
  }
  //todo 应使用useLayoutEffect,此时ref已经有值,不会起冲突
  return myUseEffect(myUseImperativeHandleImpl.bind(null, ref, create), deps)
}