/*******************************************************************************************
 * 将element包裹一层,作为FORWARD_REF_TYPE类型节点
 * 于markRef的时候记录ref
 * 在render阶段创建fiber节点时(createFiberAndConnect)， 将该类型节点的render函数取出执行,注入ref
 * 而普通的函数组件,markRef的时候会阻止ref的传递, (由于ref只能绑定给dom节点)
 * 这个API只做了一件事,将组件函数包装为FORWARD_REF_TYPE,后续按照forwardRef处理
 * *****************************************************************************************/



import { ElementNode } from '../myReactCore/Interface'
import { MEMO_TYPE, FORWARD_REF_TYPE } from '../myJSX/elementType'

export function forwardRef(render: (props: any, ref: any) => ElementNode) {
  if (typeof render !== 'function') {
    console.error('forwardRef 需要接收一个函数组件');
  }
  if (render.length !== 2) {
    console.error('forwardRef 内的函数组件需要传递两个参数 props,ref');
  }
  //@ts-ignore
  if (render?.$$typeof === MEMO_TYPE) {
    console.error(`
    forwardRef 无法处理Memo函数,
    请使用memo(forwardRef(...))代替forwardRef(memo(...))
    `);
  }


  const newElementType = {
    $$typeof: Symbol.for(FORWARD_REF_TYPE),
    render
  }

  return newElementType;
}