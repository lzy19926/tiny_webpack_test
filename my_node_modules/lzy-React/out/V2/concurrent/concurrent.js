"use strict";
// 本工具提供了时间切片和concurrent模式的方法实现
//! react会定义每一帧的工作时间 默认5s (每16.6ms会执行5ms的React任务,剩下的时间交给浏览器,防止卡顿)
//! shouldYieldToHost在外部执行workLoop时(render时)  判断是否让出主线程
Object.defineProperty(exports, "__esModule", { value: true });
exports.afterRender = exports.afterUpdateRender = exports.concurrentWhileHook = exports.concurrentWhile = exports.WhileCodeCutter = void 0;
//!  --------------切片执行while循环类---------------
class WhileCodeCutter {
    constructor() {
        this.yieldInterval = 5;
        this.deadLine = 0;
        this.isMessageChannelRunnig = false;
        this.scheduledHostCallBack = null;
        this.channel = new MessageChannel();
        this.port = this.channel.port2;
        this.onWhileDone = () => { };
        this.getCurrentTime = () => performance.now();
        this.shouldYieldToHost = () => this.getCurrentTime() >= this.deadLine;
        this.channel.port1.onmessage = this.performWorkUntilDeadline;
        this.checkEnvironment();
    }
    // 检查使用环境
    checkEnvironment() {
        if (typeof window === 'undefined') {
            throw new Error('请在浏览器环境下使用');
        }
        if (!MessageChannel) {
            throw new Error('本工具仅兼容所有人类使用的浏览器(请不要使用IE谢谢)');
        }
    }
    // 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
    requestHostCallback(cb) {
        this.scheduledHostCallBack = cb;
        if (!this.isMessageChannelRunnig) {
            this.isMessageChannelRunnig = true;
            this.port.postMessage(null);
        }
    }
    // 执行单次切片的逻辑
    performWorkUntilDeadline() {
        console.log(`执行单个${this.yieldInterval}ms的任务`);
        // 如果没有用户任务  状态直接改为false
        if (!this.scheduledHostCallBack) {
            this.isMessageChannelRunnig = false;
        }
        // 如果有用户任务
        if (this.scheduledHostCallBack !== null) {
            let currentTime = this.getCurrentTime();
            this.deadLine = currentTime + this.yieldInterval; // 停止react任务的时间
            const shouldContinue = true;
            try {
                const hasMoreWork = this.scheduledHostCallBack(shouldContinue, currentTime); // 执行workLoop
                // 如果执行完毕  初始化工作环境
                if (!hasMoreWork) {
                    this.isMessageChannelRunnig = false;
                    this.scheduledHostCallBack = null;
                }
                // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
                if (hasMoreWork) {
                    this.port.postMessage(null);
                }
            }
            catch (error) {
                this.port.postMessage(null);
                throw error;
            }
        }
    }
    //!  --------------封装的切片执行while循环函数---------------
    While(getCondition, handler, yieldInterval, afterWhile) {
        // 设置切片时间
        yieldInterval = yieldInterval;
        // 创建whild循环体
        let workLoop = () => {
            while (!this.shouldYieldToHost() && getCondition()) {
                handler();
            }
            if (!getCondition()) {
                this.onWhileDone();
            }
            return getCondition();
        };
        this.requestHostCallback(workLoop);
    }
}
exports.WhileCodeCutter = WhileCodeCutter;
//!  --------------切片执行while循环函数---------------
// 使用说明  
// 可以将while循环根据拆成多个短任务,每帧执行一个短任务 (通过yieldInterval设置短任务时间)
// 使用案例
// while (a < 100) {
//     a++
// }
// 将上面的一个while长任务拆分成多个5ms的短任务
// const getCondition = () => a < 100
// const handler = () => { a++ }
// concurrentWhile(getCondition, handler, 5)
//  getCondition :()=>boolean   // 获取while循环条件的函数
//  handler:()=>any             // while循环体
//  yieldInterval? :number      // 每帧执行while循环的时间ms
function concurrentWhile(getCondition, handler, yieldInterval, afterWhile) {
    // 判断环境
    if (typeof window === 'undefined') {
        throw new Error('请在浏览器环境下使用');
    }
    if (!MessageChannel) {
        throw new Error('本工具仅兼容所有人类使用的浏览器(请不要使用IE谢谢)');
    }
    let getCurrentTime = () => performance.now();
    let deadLine = 0; // 本帧react应该停止的时间
    let isMessageChannelRunnig = false; // 本帧react的任务是否在执行
    let scheduledHostCallBack = null; // 已经计算过的用户事件(workLoop)
    let shouldYieldToHost = () => getCurrentTime() >= deadLine; // 超过deadLine时让出JS主线程给用户
    let channel = new MessageChannel(); // 建立通信 port用来发布任务
    let port = channel.port2; // 当port1收到消息时会执行react渲染短任务
    // 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
    const requestHostCallback = (cb) => {
        scheduledHostCallBack = cb;
        if (!isMessageChannelRunnig) {
            isMessageChannelRunnig = true;
            port.postMessage(null);
        }
    };
    // 执行单次切片的逻辑
    const performWorkUntilDeadline = () => {
        console.log(`-----${yieldInterval}ms切片-----`);
        // 如果没有用户任务  状态直接改为false
        if (!scheduledHostCallBack) {
            isMessageChannelRunnig = false;
        }
        // 如果有用户任务
        if (scheduledHostCallBack !== null) {
            let currentTime = getCurrentTime();
            deadLine = currentTime + yieldInterval; // 停止react任务的时间
            const shouldContinue = true;
            try {
                const hasMoreWork = scheduledHostCallBack(shouldContinue, currentTime); // 执行workLoop
                // 如果执行完毕  初始化工作环境
                if (!hasMoreWork) {
                    isMessageChannelRunnig = false;
                    scheduledHostCallBack = null;
                }
                // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
                if (hasMoreWork) {
                    port.postMessage(null);
                }
            }
            catch (error) {
                port.postMessage(null);
                throw error;
            }
        }
    };
    // 初始化工作环境
    yieldInterval = yieldInterval || 5; // 每一帧留给react的工作时间
    channel.port1.onmessage = performWorkUntilDeadline;
    // 创建whild循环体
    let workLoop = () => {
        while (!shouldYieldToHost() && getCondition()) {
            handler();
        }
        return getCondition();
    };
    requestHostCallback(workLoop);
}
exports.concurrentWhile = concurrentWhile;
// 各种while执行完毕后的钩子
exports.concurrentWhileHook = {
    afterRender: undefined,
    afterUpdateRender: undefined,
};
// 注册钩子函数
function afterUpdateRender(callback) {
    exports.concurrentWhileHook.afterUpdateRender = callback;
}
exports.afterUpdateRender = afterUpdateRender;
// 注册钩子函数
function afterRender(callback) {
    exports.concurrentWhileHook.afterRender = callback;
}
exports.afterRender = afterRender;
