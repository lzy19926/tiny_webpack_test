"use strict";
// 本工具提供了时间切片和concurrent模式的方法实现
//! react会定义每一帧的工作时间 默认5s (每16.6ms会执行5ms的React任务,剩下的时间交给浏览器,防止卡顿)
//! shouldYieldToHost在外部执行workLoop时(render时)  判断是否让出主线程
Object.defineProperty(exports, "__esModule", { value: true });
exports.concurrentWhile = void 0;
if (typeof window === 'undefined') {
    throw new Error('请在浏览器环境下使用');
}
if (!MessageChannel) {
    throw new Error('本工具仅兼容所有人类使用的浏览器(请不要使用IE谢谢)');
}
let getCurrentTime = () => performance.now();
let yieldInterval = 5; // 每一帧留给react的工作时间
let deadLine = 0; // 本帧react应该停止的时间
let isMessageChannelRunnig = false; // 本帧react的任务是否在执行
let scheduledHostCallBack = null; // 已经计算过的用户事件(workLoop)
let shouldYieldToHost = () => getCurrentTime() >= deadLine; // 超过deadLine时让出JS主线程给用户
// 建立通信
// port用来发布任务
// 当port1收到消息时会执行react渲染短任务
const channel = new MessageChannel();
const port = channel.port2;
channel.port1.onmessage = performWorkUntilDeadline;
// 如果用户任务未执行  执行channel中的用户任务(传入workLoop)
function requestHostCallback(cb) {
    scheduledHostCallBack = cb;
    if (!isMessageChannelRunnig) {
        isMessageChannelRunnig = true;
        port.postMessage(null);
    }
}
// 执行单次切片的逻辑
function performWorkUntilDeadline() {
    console.log(`执行单个${yieldInterval}ms的任务`);
    // 如果没有用户任务  状态直接改为false
    if (!scheduledHostCallBack) {
        isMessageChannelRunnig = false;
    }
    // 如果有用户任务
    if (scheduledHostCallBack !== null) {
        let currentTime = getCurrentTime();
        deadLine = currentTime + yieldInterval; // 停止react任务的时间
        const shouldContinue = true;
        try {
            const hasMoreWork = scheduledHostCallBack(shouldContinue, currentTime); // 执行workLoop
            // 如果执行完毕  初始化工作环境
            if (!hasMoreWork) {
                isMessageChannelRunnig = false;
                scheduledHostCallBack = null;
            }
            // 如果此帧的处理时间已过>5ms  则再发起一个宏任务 继续执行
            if (hasMoreWork) {
                port.postMessage(null);
            }
        }
        catch (error) {
            port.postMessage(null);
            throw error;
        }
    }
}
//!  --------------切片执行while循环函数---------------
// 使用说明  
// 可以将while循环根据拆成多个短任务,每帧执行一个短任务 (通过yieldInterval设置短任务时间)
// 使用案例
// while (a < 100) {
//     a++
// }
// 将上面的一个while长任务拆分成多个5ms的短任务
// const getCondition = () => a < 100
// const handler = () => { a++ }
// concurrentWhile(getCondition, handler, 5)
// @params 
//  getCondition :()=>boolean  // 获取while循环条件的函数
//  handler:()=>any            // while循环体
//  yieldInterval :number      // 每帧执行while循环的时间ms
function concurrentWhile(getCondition, handler, yieldInterval, afterWhile) {
    // 设置切片时间
    yieldInterval = yieldInterval;
    // 创建whild循环体
    let workLoop = () => {
        while (!shouldYieldToHost() && getCondition()) {
            handler();
        }
        // 如果未完成while 继续切片执行
        return getCondition();
    };
    requestHostCallback(workLoop);
    // 循环结束后回调
    if (!getCondition()) {
        afterWhile();
    }
}
exports.concurrentWhile = concurrentWhile;
// 测试demo
const test = () => {
    let a = 0;
    const getCondition = () => a < 1000;
    const handler = () => {
        console.log('执行handler');
        a++;
    };
    concurrentWhile(getCondition, handler, 5);
};
