"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createFiberWorkLoop = exports.createFiberWorkLoop2 = exports.handleProps = exports.createTextElement = exports.createDomElement = exports.createAlternate_concurrent = exports.createAlternate = exports.createFiber = exports.createFiberTree_concurrent = exports.createFiberTree = exports.transformFiberTreeToBinadyTree = exports.createFiberTree_base = void 0;
const GlobalFiber_1 = require("../myReactCore/GlobalFiber");
const createElement_1 = require("../myJSX/createElement");
const concurrent_1 = require("../concurrent/concurrent");
//! 通过element树生成fiber树(普通树)
function createFiberTree_base(elementNode, parentFiber, tag) {
    let newFiberNode = new GlobalFiber_1.FiberNode('mount', '$1');
    //todo 切换当前工作fiber
    GlobalFiber_1.global.workInprogressFiberNode = newFiberNode;
    newFiberNode.tag = elementNode.tag;
    newFiberNode._parent = parentFiber;
    newFiberNode._element = elementNode;
    elementNode.fiber = newFiberNode;
    //如果是创建placement节点 添加tag
    if (tag === 'Placement') {
        newFiberNode.effectTag = 'Placement';
    }
    //如果tag大写 解析为FC组件节点 重新生成element  挂载props
    if (elementNode.tag[0] === elementNode.tag[0].toUpperCase()) {
        newFiberNode.nodeType = 'FunctionComponent';
        newFiberNode.stateNode = elementNode.ref;
        elementNode.children = [elementNode.ref.call(undefined, elementNode.props)]; //! 挂载props
    }
    //解析为text节点
    else if (elementNode.tag === 'text') {
        newFiberNode.nodeType = 'HostText';
        newFiberNode.text = elementNode.text;
        // createTextElement(newFiberNode)
    }
    //解析为普通dom节点
    else {
        newFiberNode.nodeType = 'HostComponent';
        // createDomElement(newFiberNode)
    }
    if (elementNode.children) {
        const childrenFiber = [];
        elementNode.children.forEach((childElement) => {
            const childFiber = createFiberTree_base(childElement, newFiberNode, tag);
            childrenFiber.push(childFiber);
        });
        newFiberNode.children = childrenFiber;
    }
    // 改变状态
    newFiberNode.fiberFlags = 'update';
    return newFiberNode;
}
exports.createFiberTree_base = createFiberTree_base;
//! 将普通fiber树转化为二叉fiber树
function transformFiberTreeToBinadyTree(fiberTree) {
    const rootFiberNode = fiberTree;
    const children = rootFiberNode.children;
    Object.assign(rootFiberNode, {
        _child: undefined,
        _sibling: undefined,
    });
    if (children) {
        children.forEach((child, index) => {
            Object.assign(child, {
                _child: undefined,
                _sibling: undefined,
            });
            if (index === 0) {
                rootFiberNode._child = child;
                delete rootFiberNode.children;
            }
            else {
                children[index - 1]._sibling = child;
                delete children[index - 1].children;
            }
            if (child.children) {
                transformFiberTreeToBinadyTree(child);
            }
        });
    }
    return rootFiberNode;
}
exports.transformFiberTreeToBinadyTree = transformFiberTreeToBinadyTree;
//! 综合方法  创建二叉fiber树
function createFiberTree(elementNode, parentFiber, tag) {
    const rootFiber = createFiberTree_base(elementNode, parentFiber, tag);
    const rootFiberBinady = transformFiberTreeToBinadyTree(rootFiber);
    return rootFiberBinady;
}
exports.createFiberTree = createFiberTree;
//! ------------初始创建fiberTree-------------------
function createFiberTree_concurrent(rootElement) {
    //todo------- 遍历二叉element树----
    const stack = [];
    let current;
    let currentAlt;
    let rootFiber;
    let rootFiberAlt;
    // 创建App节点
    rootFiber = current = createRootFiber(rootElement);
    rootFiberAlt = currentAlt = createAlternate(current);
    // 从App的child开始遍历
    if (rootElement._child)
        stack.push({
            from: 'child',
            fromFiber: rootFiber,
            fromFiberAlt: rootFiberAlt,
            elementNode: rootElement._child,
            parentFiber: rootFiber
        });
    // 将 render的while循环遍历fiberTree的逻辑切片执行
    const getCondition = () => stack.length > 0;
    (0, concurrent_1.concurrentWhile)(getCondition, () => {
        // 根据element创建一个fiber以及它的alternate
        //  stack.pop()为此时遍历到的element   执行处理逻辑
        let { from, fromFiber, fromFiberAlt, elementNode, parentFiber } = stack.pop();
        current = createFiber(elementNode, parentFiber);
        //创建alternate
        currentAlt = createAlternate_concurrent(current);
        // 链接前后fiber和alternateFiber
        if (from === 'child') {
            fromFiber._child = current;
            fromFiberAlt._child = currentAlt;
        }
        else if (from === 'sibling') {
            fromFiber._sibling = current;
            fromFiberAlt._sibling = currentAlt;
        }
        // 将下一个节点入栈 继续遍历 (注意这里childElement的声明要放在后面,否则可能会保存为undefined)
        let childElement = elementNode._child;
        let siblingElement = elementNode._sibling;
        if (siblingElement) {
            stack.push({
                from: 'sibling',
                fromFiber: current,
                fromFiberAlt: currentAlt,
                elementNode: elementNode._sibling,
                parentFiber: parentFiber
            });
        }
        if (childElement) {
            stack.push({
                from: 'child',
                fromFiber: current,
                fromFiberAlt: currentAlt,
                elementNode: elementNode._child,
                parentFiber: current
            });
        }
        //执行后续操作
        if (!getCondition()) {
            concurrent_1.concurrentWhileHook.afterRender();
        }
    });
    return rootFiber;
}
exports.createFiberTree_concurrent = createFiberTree_concurrent;
//!------ 单独处理创建AppFiber节点
function createRootFiber(rootElement) {
    let rootFiber = new GlobalFiber_1.FiberNode('mount', '$1');
    GlobalFiber_1.global.workInprogressFiberNode = rootFiber; //todo 切换当前工作fiber
    // 首先创建rootFiber(单独处理app节点) 
    const childElementTree = rootElement.ref.call(undefined, rootElement.props); //! 挂载props
    rootElement._child = (0, createElement_1.transformElementTreeToBinadyTree)(childElementTree, rootElement); //! 重新生成新的二叉element树
    rootFiber.tag = rootElement.tag;
    rootFiber._element = rootElement;
    rootElement.fiber = rootFiber;
    rootFiber.nodeType = 'AppNode';
    rootFiber.stateNode = rootElement.ref;
    rootFiber.fiberFlags = 'update';
    return rootFiber;
}
//!------ 创建单个fiber节点
function createFiber(elementNode, parentFiber) {
    // 创建newFiber
    let newFiberNode = new GlobalFiber_1.FiberNode('mount', '$1');
    // 切换当前工作fiber
    GlobalFiber_1.global.workInprogressFiberNode = newFiberNode;
    // 给fiber赋值 并链接parent
    newFiberNode._parent = parentFiber;
    newFiberNode.tag = elementNode.tag;
    newFiberNode._element = elementNode;
    elementNode.fiber = newFiberNode;
    //如果tag大写 解析为FC组件节点 重新生成element  挂载props
    if (elementNode.tag[0] === elementNode.tag[0].toUpperCase()) {
        newFiberNode.nodeType = 'FunctionComponent';
        newFiberNode.stateNode = elementNode.ref;
        const childElementTree = elementNode.ref.call(undefined, elementNode.props); //! 挂载props
        elementNode._child = (0, createElement_1.transformElementTreeToBinadyTree)(childElementTree, elementNode); //! 重新生成新的二叉element树
    }
    //解析为text节点
    else if (elementNode.tag === 'text') {
        newFiberNode.nodeType = 'HostText';
        newFiberNode.text = elementNode.text;
    }
    //解析为普通dom节点
    else {
        newFiberNode.nodeType = 'HostComponent';
    }
    // 更改状态
    newFiberNode.fiberFlags = 'update';
    return newFiberNode;
}
exports.createFiber = createFiber;
//! -------------创建复制的alternate------------------
function createAlternate(currentFiber, tag) {
    let alternateFiber = new GlobalFiber_1.FiberNode('mount', '$2');
    let child = currentFiber._child;
    let sibling = currentFiber._sibling;
    //如果是创建placement节点 添加tag
    if (tag === 'Placement') {
        alternateFiber.effectTag = 'Placement';
    }
    //! 将一些属性复制给workInProgress
    alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer;
    alternateFiber.updateQueue = currentFiber.updateQueue;
    alternateFiber.hookIndex = currentFiber.hookIndex;
    alternateFiber.memorizedState = currentFiber.memorizedState;
    alternateFiber.nodeType = currentFiber.nodeType;
    alternateFiber.tag = currentFiber.tag;
    alternateFiber.text = currentFiber.text;
    alternateFiber._element = currentFiber._element;
    alternateFiber.stateNode = currentFiber.stateNode;
    //! 链接两个fiber 
    alternateFiber.alternate = currentFiber;
    currentFiber.alternate = alternateFiber;
    //! 链接parent
    if (currentFiber._parent) {
        alternateFiber._parent = currentFiber._parent.alternate;
        currentFiber._parent.alternate = alternateFiber._parent;
    }
    // 深度优先递归执行
    if (child) {
        const childAlternateFiber = createAlternate(child, tag);
        alternateFiber._child = childAlternateFiber;
    }
    if (sibling) {
        const siblingAlternateFiber = createAlternate(sibling, tag);
        alternateFiber._sibling = siblingAlternateFiber;
    }
    // 更改状态
    alternateFiber.fiberFlags = 'update';
    return alternateFiber;
}
exports.createAlternate = createAlternate;
// 创建单个alt
function createAlternate_concurrent(currentFiber) {
    let alternateFiber = new GlobalFiber_1.FiberNode('mount', '$2');
    //! 将一些属性复制给workInProgress
    alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer;
    alternateFiber.updateQueue = currentFiber.updateQueue;
    alternateFiber.hookIndex = currentFiber.hookIndex;
    alternateFiber.memorizedState = currentFiber.memorizedState;
    alternateFiber.nodeType = currentFiber.nodeType;
    alternateFiber.tag = currentFiber.tag;
    alternateFiber.text = currentFiber.text;
    //! 链接两个fiber 
    alternateFiber.alternate = currentFiber;
    currentFiber.alternate = alternateFiber;
    //! 链接parent
    if (currentFiber._parent) {
        alternateFiber._parent = currentFiber._parent.alternate;
        currentFiber._parent.alternate = alternateFiber._parent;
    }
    // 更改状态
    alternateFiber.fiberFlags = 'update';
    return alternateFiber;
}
exports.createAlternate_concurrent = createAlternate_concurrent;
//! -------------创建html并挂载到fiber节点上--------------------
function createDomElement(fiber) {
    var _a;
    //找到父dom节点 将创建好的dom节点添加进去appendChild
    //如果有兄弟节点则插入insertBefore
    const parentDom = getParentDom(fiber);
    const domElement = document.createElement(fiber.tag);
    fiber.stateNode = domElement;
    fiber.alternate.stateNode = domElement;
    handleProps(fiber, domElement);
    const siblingDom = (_a = fiber === null || fiber === void 0 ? void 0 : fiber._sibling) === null || _a === void 0 ? void 0 : _a.stateNode;
    // 需要判断sibling是否为dom节点
    if (siblingDom && typeof siblingDom !== 'function') {
        parentDom.insertBefore(domElement, siblingDom);
    }
    else {
        parentDom.appendChild(domElement);
    }
    return domElement;
}
exports.createDomElement = createDomElement;
//! -------------创建text节点并挂载到fiber节点上--------------------
function createTextElement(fiber) {
    //找到父dom节点 将创建好的dom节点添加进去
    const parentDom = getParentDom(fiber);
    const textElement = document.createTextNode(fiber.text);
    fiber.stateNode = textElement;
    fiber.alternate.stateNode = textElement;
    if (fiber._sibling) {
        const siblingDom = fiber._sibling.stateNode;
        parentDom.insertBefore(textElement, siblingDom);
    }
    else {
        parentDom.appendChild(textElement);
    }
    return textElement;
}
exports.createTextElement = createTextElement;
//! ----------找到父dom节点---------------------
function getParentDom(fiber) {
    let parentNode = fiber._parent;
    let parentDom = parentNode === null || parentNode === void 0 ? void 0 : parentNode.stateNode;
    if (!parentNode) {
        return document.getElementById('root');
    }
    while (typeof parentDom === 'function') {
        parentNode = parentNode._parent;
        if (!parentNode) {
            return document.getElementById('root');
        }
        parentDom = parentNode.stateNode;
    }
    return parentDom;
}
//! 对标签中的属性进行处理 给dom节点添加标签 (未完成)
function handleProps(fiber, dom) {
    const props = fiber._element.props;
    for (let key in props) {
        const value = props[key];
        switch (key) {
            //todo  处理className 
            case 'className':
                dom.setAttribute("class", value);
                break;
            //todo  处理class
            case 'class':
                dom.setAttribute("class", value);
                break;
            //todo  处理点击事件(还需处理其他事件)
            case 'onClick':
                dom.onclick = value;
                break;
            //todo  处理其他
            default:
                dom.setAttribute(key, value);
                break;
        }
    }
}
exports.handleProps = handleProps;
//todo 深度优先遍历  优先进入child  再进入sibling 都无的情况返回parent 进入sibling （交替执行begin和completeWork）
function createFiberWorkLoop2(elementNode) {
    if (Symbol.keyFor(elementNode.$$typeof) === 'textElement') {
        console.log('执行completeWork', elementNode.$$typeof);
        if (elementNode._child) {
            createFiberWorkLoop(elementNode._child);
        }
        if (elementNode._sibling) {
            createFiberWorkLoop(elementNode._sibling);
        }
    }
    else {
        console.log('执行beginWork', elementNode.$$typeof);
        if (elementNode._child) {
            createFiberWorkLoop(elementNode._child);
        }
        if (elementNode._sibling) {
            createFiberWorkLoop(elementNode._sibling);
        }
        console.log('执行completeWork', elementNode.$$typeof);
    }
}
exports.createFiberWorkLoop2 = createFiberWorkLoop2;
//todo 深度优先遍历  构建fiber树
function createFiberWorkLoop(elementNode) {
    console.log('执行beginWork', elementNode.$$typeof);
    if (elementNode._child) {
        console.log('进入child');
        createFiberWorkLoop(elementNode._child);
    }
    if (elementNode._sibling) {
        console.log('进入sibling');
        createFiberWorkLoop(elementNode._sibling);
    }
}
exports.createFiberWorkLoop = createFiberWorkLoop;
