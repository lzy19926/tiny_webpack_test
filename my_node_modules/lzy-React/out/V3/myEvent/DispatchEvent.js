"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.dispatchContinuousEvent = exports.dispatchDiscreteEvent = exports.dispatchEvent = void 0;
const Constance_1 = require("../myReactCore/Constance");
const Constance_2 = require("../myReactCore/Constance");
const eventRegister_1 = require("./eventRegister");
const EventPriority_1 = require("./EventPriority");
//todo 触发普通事件
function dispatchEvent(domEventName, targetContainer, nativeEvent, targetFiber) {
    //1/ 准备需要的参数
    const nativeEventTarget = getEventTarget(nativeEvent); //获取触发事件的dom
    const dispatchQueue = []; // dispatchQueue 提取所有监听的处理函数放到 dispatchQueue 当中
    if (!targetFiber) {
        targetFiber = (0, Constance_2.getFiberNodeFromDom)(nativeEventTarget); //获取触发dom对应的fiber(源码中为blockedOn)
    }
    //2. 收集沿途的冒泡事件
    if (domEventName == 'click') {
        extractEvents(dispatchQueue, domEventName, targetFiber, nativeEvent, nativeEventTarget, targetContainer);
    }
    //3.模拟捕获阶段和冒泡阶段的执行流程，去执行所有的监听处理函数。
    processDispatchQueue(dispatchQueue);
    if (domEventName == 'click') {
        // console.log(domEventName, '触发dispatchEvent');
        // console.log(nativeEvent, 'nativeEvent');
        // console.log(targetFiber, 'targetFiber');
        // console.log(targetContainer, 'targetContainer');
        // console.log(nativeEventTarget, '原生事件target');
    }
}
exports.dispatchEvent = dispatchEvent;
//todo 触发DiscreteEvent离散事件(最高优先级)  用户事件级别
// 全局维护了一个当前时间的优先级CurrentUpdatePriority, 默认为default级
// 触发click事件时, 修改当前优先级为Discrete,事件执行完毕后还原
function dispatchDiscreteEvent(domEventName, targetContainer, nativeEvent) {
    const previousPriority = (0, EventPriority_1.getCurrentUpdatePriority)();
    try {
        (0, EventPriority_1.setCurrentUpdatePriority)(EventPriority_1.DiscreteEventPriority);
        dispatchEvent(domEventName, targetContainer, nativeEvent, null);
    }
    finally {
        (0, EventPriority_1.setCurrentUpdatePriority)(previousPriority); // 还原当前优先级
    }
}
exports.dispatchDiscreteEvent = dispatchDiscreteEvent;
//todo 触发ContinuousEvent持续事件(次高优先级)
function dispatchContinuousEvent(domEventName, targetContainer, nativeEvent) {
    const previousPriority = (0, EventPriority_1.getCurrentUpdatePriority)();
    try {
        (0, EventPriority_1.setCurrentUpdatePriority)(EventPriority_1.ContinuousEventPriority);
        dispatchEvent(domEventName, targetContainer, nativeEvent, null);
    }
    finally {
        (0, EventPriority_1.setCurrentUpdatePriority)(previousPriority); // 还原当前优先级
    }
}
exports.dispatchContinuousEvent = dispatchContinuousEvent;
function extractEvents(dispatchQueue, domEventName, targetFiber, nativeEvent, nativeEventTarget, targetContainer) {
    let isCapture = false;
    // 冒泡层层收集listeners
    // 捕获情况和非捕获情况的listeners不同
    let listeners = isCapture
        ? accumulateCapturedEventListeners()
        : accumulateEventListeners(targetFiber, domEventName, nativeEventTarget);
    //创建合成事件对象  queue推入
    if (listeners.length > 0) {
        // const event = new SyntheticEvent() 
        const event = nativeEvent;
        dispatchQueue.push({ event, listeners });
    }
}
// 收集click事件(Capture事件)
// 从当前fiber出发,根据事件名"onClick",一直向上收集props(sourcePool)中所有事件
function accumulateCapturedEventListeners() {
    const listeners = [];
    return listeners;
}
// 收集click事件
// 从当前fiber出发,根据事件名"onClick",一直向上收集props(sourcePool)中所有事件
function accumulateEventListeners(targetFiber, domEventName, nativeEventTarget) {
    var _a;
    const listeners = [];
    const reactName = eventRegister_1.topLevelEventsToReactNames.get(domEventName);
    if (reactName === undefined)
        return listeners;
    // 冒泡收集listener
    let currentFiber = targetFiber;
    while (currentFiber) {
        let props = (_a = currentFiber._element) === null || _a === void 0 ? void 0 : _a.props;
        let nativeListener = props === null || props === void 0 ? void 0 : props[reactName];
        nativeListener && listeners.push(newDispatchListener(currentFiber, nativeListener, nativeEventTarget));
        currentFiber = currentFiber._parent;
    }
    return listeners;
}
// 创建一个newDispatchListener实例
function newDispatchListener(fiber, listener, targetDom) {
    return {
        fiber,
        listener,
        targetDom
    };
}
//3.模拟捕获阶段和冒泡阶段的执行流程，去执行所有的监听处理函数。
function processDispatchQueue(dispatchQueue) {
}
// 从原生event对象中获取target
function getEventTarget(nativeEvent) {
    // 兼容IE9
    let target = nativeEvent.target || nativeEvent.srcElement || window;
    if (target.correspondingUseElement) {
        target = target.correspondingUseElement;
    }
    // 兼容Safari
    return target.nodeType === Constance_1.TEXT_NODE ? target.parentNode : target;
}
