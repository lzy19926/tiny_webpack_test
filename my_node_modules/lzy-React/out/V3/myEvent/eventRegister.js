"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getEventPriority = exports.addEventCaptureListener = exports.addEventBubbleListener = exports.removeEventListener = exports.listenToAllSupportedEvents = exports.topLevelEventsToReactNames = void 0;
const domEventsName_1 = require("./domEventsName");
const EventPriority_1 = require("./EventPriority");
exports.topLevelEventsToReactNames = new Map();
// 注册React事件名  生成Map{'click'：'onClick'}
function registerSimpleEvents() {
    for (let i = 0; i < domEventsName_1.DOMEventNameList.length; i++) {
        const domEventName = domEventsName_1.DOMEventNameList[i]; // click
        const capitalizedEvent = domEventName[0].toUpperCase() + domEventName.slice(1); //Click(大写)
        const ReactEventName = "on" + capitalizedEvent;
        exports.topLevelEventsToReactNames.set(domEventName, ReactEventName);
    }
}
registerSimpleEvents();
// 启动监听所有原生事件
function listenToAllSupportedEvents(rootContainerElement) {
    domEventsName_1.DOMEventNameList.forEach((domEventName) => {
        listenToNativeEvent(domEventName, true, rootContainerElement);
    });
    console.log(exports.topLevelEventsToReactNames);
}
exports.listenToAllSupportedEvents = listenToAllSupportedEvents;
function listenToNativeEvent(domEventName, isCapture, rootContainerElement) {
    // 给事件进行优先级排序,创建真正的dispatch执行对象
    const eventPriority = getEventPriority(domEventName);
    console.log(eventPriority, domEventName, '---');
    // 根据优先级,创建listener, 进行绑定
    let listenerWrapper;
    switch (eventPriority) {
        case EventPriority_1.DiscreteEventPriority:
            listenerWrapper = dispatchDiscreteEvent; //最高级
            break;
        case EventPriority_1.ContinuousEventPriority:
            listenerWrapper = dispatchContinuousEvent; // 次高级
            break;
        case EventPriority_1.DefaultEventPriority: // 普通级
        default:
            listenerWrapper = dispatchEvent; // 等待级
            break;
    }
    let listener = listenerWrapper.bind(null, domEventName, null, rootContainerElement);
    if (isCapture) {
        addEventCaptureListener(rootContainerElement, domEventName, listener);
    }
    else {
        addEventBubbleListener(rootContainerElement, domEventName, listener);
    }
}
function removeEventListener(target, eventType, listener, capture) {
    target.removeEventListener(eventType, listener, capture);
}
exports.removeEventListener = removeEventListener;
function addEventBubbleListener(target, eventType, listener) {
    target.addEventListener(eventType, listener, false);
    return listener;
}
exports.addEventBubbleListener = addEventBubbleListener;
function addEventCaptureListener(target, eventType, listener) {
    target.addEventListener(eventType, listener, true);
    return listener;
}
exports.addEventCaptureListener = addEventCaptureListener;
// 将不同event进行分类
function getEventPriority(domEventName) {
    switch (domEventName) {
        //! 无return时会返回2  也就是DiscreteEventPriority 
        //! 绝大部分用户事件优先级为2 最高级
        case 'cancel':
        case 'click':
        case 'close':
        case 'contextmenu':
        case 'copy':
        case 'cut':
        case 'auxclick':
        case 'dblclick':
        case 'dragend':
        case 'dragstart':
        case 'drop':
        case 'focusin':
        case 'focusout':
        case 'input':
        case 'invalid':
        case 'keydown':
        case 'keypress':
        case 'keyup':
        case 'mousedown':
        case 'mouseup':
        case 'paste':
        case 'pause':
        case 'play':
        case 'pointercancel':
        case 'pointerdown':
        case 'pointerup':
        case 'ratechange':
        case 'reset':
        case 'resize':
        case 'seeked':
        case 'submit':
        case 'touchcancel':
        case 'touchend':
        case 'touchstart':
        case 'volumechange':
        // Used by polyfills:
        // eslint-disable-next-line no-fallthrough
        case 'change':
        case 'selectionchange':
        case 'textInput':
        case 'compositionstart':
        case 'compositionend':
        case 'compositionupdate':
        // Only enableCreateEventHandleAPI:
        // eslint-disable-next-line no-fallthrough
        case 'beforeblur':
        case 'afterblur':
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case 'beforeinput':
        case 'blur':
        case 'fullscreenchange':
        case 'focus':
        case 'hashchange':
        case 'popstate':
        case 'select':
        case 'selectstart':
            return EventPriority_1.DiscreteEventPriority;
        case 'drag':
        case 'dragenter':
        case 'dragexit':
        case 'dragleave':
        case 'dragover':
        case 'mousemove':
        case 'mouseout':
        case 'mouseover':
        case 'pointermove':
        case 'pointerout':
        case 'pointerover':
        case 'scroll':
        case 'toggle':
        case 'touchmove':
        case 'wheel':
        // Not used by React but could be by user code:
        // eslint-disable-next-line no-fallthrough
        case 'mouseenter':
        case 'mouseleave':
        case 'pointerenter':
        case 'pointerleave':
            return EventPriority_1.ContinuousEventPriority;
        case 'message':
            return EventPriority_1.DiscreteEventPriority;
        default:
            return EventPriority_1.DefaultEventPriority;
    }
}
exports.getEventPriority = getEventPriority;
// 触发普通事件
function dispatchEvent(domEventName, nativeEvent, targetInst, targetContainer) {
    console.log('触发dispatchEvent');
    const dispatchQueue = [];
    //1. 提取所有监听的处理函数放到 dispatchQueue 当中
    // extractEvents()
    //2.模拟捕获阶段和冒泡阶段的执行流程，去执行所有的监听处理函数。
    // processDispatchQueue(dispatchQueue, eventSystemFlags);
}
//todo 触发DiscreteEvent离散事件(最高优先级)  用户事件级别
// 全局维护了一个当前时间的优先级CurrentUpdatePriority, 默认为default级
// 触发click事件时, 修改当前优先级为Discrete,事件执行完毕后还原
function dispatchDiscreteEvent(domEventName, targetContainer, nativeEvent) {
    const previousPriority = (0, EventPriority_1.getCurrentUpdatePriority)();
    try {
        (0, EventPriority_1.setCurrentUpdatePriority)(EventPriority_1.DiscreteEventPriority);
        dispatchEvent(domEventName, nativeEvent, null, targetContainer);
    }
    finally {
        (0, EventPriority_1.setCurrentUpdatePriority)(previousPriority); // 还原当前优先级
    }
}
//todo 触发ContinuousEvent持续事件(次高优先级)
function dispatchContinuousEvent(domEventName, targetContainer, nativeEvent) {
    const previousPriority = (0, EventPriority_1.getCurrentUpdatePriority)();
    try {
        (0, EventPriority_1.setCurrentUpdatePriority)(EventPriority_1.ContinuousEventPriority);
        dispatchEvent(domEventName, nativeEvent, null, targetContainer);
    }
    finally {
        (0, EventPriority_1.setCurrentUpdatePriority)(previousPriority); // 还原当前优先级
    }
}
// 首次render/createRoot时执行
// listenToAllSupportedEvents(rootContainerElement);
