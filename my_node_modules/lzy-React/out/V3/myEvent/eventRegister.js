"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.startSyntheticEventSystem = exports.reactNameDependencies = exports.topLevelEventsToReactNames = exports.allNativeEvents = void 0;
const domEventsName_1 = require("./domEventsName");
const GlobalFiber_1 = require("../myReactCore/GlobalFiber");
const DispatchEvent_1 = require("./DispatchEvent");
const EventPriority_1 = require("./EventPriority");
exports.allNativeEvents = new Set(); // 所有原生事件集
exports.topLevelEventsToReactNames = new Map(); // 顶层事件map
// reactName映射的dom事件数组(一个react事件可能对应多个原生事件)
exports.reactNameDependencies = {};
//! --------------综合方法,启动合成事件系统--------------
function startSyntheticEventSystem(rootContainerElement) {
    console.log('------合成事件系统启动------');
    GlobalFiber_1.global.islzySyntheticEventSystemOpen = true;
    registerSimpleEvents();
    listenToAllSupportedEvents(rootContainerElement);
}
exports.startSyntheticEventSystem = startSyntheticEventSystem;
// 注册React事件  生成Map{'click'：'onClick'}
function registerSimpleEvents() {
    for (let i = 0; i < domEventsName_1.DOMEventNameList.length; i++) {
        const domEventName = domEventsName_1.DOMEventNameList[i]; // click
        const capitalizedEvent = domEventName[0].toUpperCase() + domEventName.slice(1); //Click(大写)
        const reactEventName = "on" + capitalizedEvent;
        exports.topLevelEventsToReactNames.set(domEventName, reactEventName);
        registerDirectEvent(reactEventName, [domEventName]);
        registerDirectEvent(reactEventName + 'Capture', [domEventName]); // click => clickCaputre
    }
}
// 创建reactName集合,收集所有原生事件
function registerDirectEvent(reactEventName, domEventNames) {
    exports.reactNameDependencies[reactEventName] = domEventNames;
    for (let i = 0; i < domEventNames.length; i++) {
        exports.allNativeEvents.add(domEventNames[i]);
    }
}
// 启动监听所有原生事件(非委托事件和普通事件分开处理)
function listenToAllSupportedEvents(rootContainerElement) {
    exports.allNativeEvents.forEach((domEventName) => {
        if (domEventsName_1.nonDelegatedEvents.has(domEventName)) {
            listenToNativeEvent(domEventName, false, rootContainerElement);
        }
        else {
            listenToNativeEvent(domEventName, true, rootContainerElement);
        }
    });
}
function listenToNativeEvent(domEventName, isCapturePhaseListener, rootContainerElement) {
    // console.log('监听事件', domEventName, '是否是委派事件', isCapturePhaseListener);
    // 给事件进行优先级排序,创建真正的dispatch执行对象
    const eventPriority = (0, EventPriority_1.getEventPriority)(domEventName);
    // 根据优先级,创建listener, 进行绑定
    let listenerWrapper;
    switch (eventPriority) {
        case EventPriority_1.DiscreteEventPriority: // 最高级
            listenerWrapper = DispatchEvent_1.dispatchDiscreteEvent;
            break;
        case EventPriority_1.ContinuousEventPriority: // 次高级
            listenerWrapper = DispatchEvent_1.dispatchContinuousEvent;
            break;
        case EventPriority_1.DefaultEventPriority: // 普通级
        default: // 等待级
            listenerWrapper = DispatchEvent_1.dispatchEvent;
            break;
    }
    // 在执行listener时,event会作为第四个参数传入,也就是nativeEvnet
    let listener = listenerWrapper.bind(null, domEventName, rootContainerElement);
    //! isCapturePhaseListener 是否是捕获阶段侦听器
    // (事件分为委派事件和非委派事件,一般的委派事件都是捕获阶段侦听器,非委派事件则不是)
    if (isCapturePhaseListener) {
        addEventCaptureListener(rootContainerElement, domEventName, listener);
    }
    else {
        addEventBubbleListener(rootContainerElement, domEventName, listener);
    }
}
// ! ------- 封装的原生eventListener事件-------------
function removeEventListener(target, eventType, listener, capture) {
    target.removeEventListener(eventType, listener, capture);
}
function addEventBubbleListener(target, eventType, listener) {
    target.addEventListener(eventType, listener, false);
    return listener;
}
function addEventCaptureListener(target, eventType, listener) {
    target.addEventListener(eventType, listener, true);
    return listener;
}
// 首先注册所有的原生事件
// registerSimpleEvents()
// 首次render/createRoot时启动监听所有原生事件
// listenToAllSupportedEvents(rootContainerElement);
