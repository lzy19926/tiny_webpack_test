"use strict";
//1.  生成element树，转换为二叉fiber,保存fiber进map
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateRender = exports.render = void 0;
//2.  生成新element树,查找map,有可复用的节点拿过来, 没有的打上标记添加,  map剩余的删除
const Schedular_1 = require("./Schedular");
const GlobalFiber_1 = require("./GlobalFiber");
const concurrent_1 = require("./concurrent");
const commit_1 = require("./commit");
const reconcileElement_1 = require("../myJSX/reconcileElement");
const reconcile_update_1 = require("../myJSX/reconcile_update");
const createElement_1 = require("../myJSX/createElement");
//! ----------遍历fiber  收集effect 挂载到本次root节点 识别删除节点------------------
function finishedWork(workInProgressFiber, currentFiber) {
    // 遍历fiber树 将所有Effect添加进root节点的update环链表中
    const root = workInProgressFiber;
    let rootUpdateQueue = { lastEffect: null };
    finishedWorkLoop(workInProgressFiber, rootUpdateQueue, 'root');
    // 处理好的updateQueue成为到本次root节点的updateQueue
    root.updateQueue = rootUpdateQueue;
    return root;
}
//! 遍历fiber  拼接所有的effect   
function finishedWorkLoop(workInProgressFiber, rootUpdateQueue, tag) {
    // 将updateQueue拼接到fiber的queue上
    collectEffect(workInProgressFiber, rootUpdateQueue);
    //diff两个节点 打上tag 生成Effect交给commit阶段更新
    // diffFiberNode(workInProgressFiber, null)
    // 继续遍历fiber树  拼接链表 深度优先递归执行
    const childFiber = workInProgressFiber._child;
    const siblingFiber = workInProgressFiber._sibling;
    if (childFiber) {
        finishedWorkLoop(childFiber, rootUpdateQueue);
    }
    if (siblingFiber && tag !== 'root') { // 第一次不进入组件节点的sibling
        finishedWorkLoop(siblingFiber, rootUpdateQueue);
    }
}
//! 将fiber的effect链表拼接到
function collectEffect(fiber, rootUpdateQueue) {
    if (!fiber)
        return;
    const fiberUpdateQueue = fiber.updateQueue;
    if (fiberUpdateQueue && fiberUpdateQueue.lastEffect) {
        rootUpdateQueue.lastEffect = fiberUpdateQueue.lastEffect;
        fiberUpdateQueue.lastEffect.next = rootUpdateQueue.lastEffect.next;
    }
}
//TODO--- 进行优先级排序
function scheduleFiber(workInProgressFiber) {
    return workInProgressFiber;
}
//遍历清空fiber树上的hookIndex 和 queue 和 EffectTag
function resetFiber(fiber) {
    if (!fiber)
        return;
    fiber.hookIndex = 0;
    fiber.updateQueue = null;
    fiber.effectTag = undefined;
    GlobalFiber_1.global.EffectList = { firstEffect: null, lastEffect: null, length: 0 };
    GlobalFiber_1.global.destoryEffectsArr = [];
    if (fiber._child) {
        resetFiber(fiber._child);
    }
    if (fiber._sibling) {
        resetFiber(fiber._sibling);
    }
}
//!-------- 切换当前的workInprogress树  链接到当前element树上--------------
function connectElementAndWorkInProgress(workInProgressFiber) {
    const element = workInProgressFiber._element;
    element.fiber = workInProgressFiber;
    if (workInProgressFiber._child) {
        connectElementAndWorkInProgress(workInProgressFiber._child);
    }
    if (workInProgressFiber._sibling) {
        connectElementAndWorkInProgress(workInProgressFiber._sibling);
    }
}
// 遍历fiber树,根据effectTag执行对应操作(更新)
function beginWork(workInProgressFiber) {
    (0, Schedular_1.scheduleFiberNode)(workInProgressFiber);
    if (workInProgressFiber._child) {
        beginWork(workInProgressFiber._child);
    }
    if (workInProgressFiber._sibling) {
        beginWork(workInProgressFiber._sibling);
    }
    return workInProgressFiber;
}
//! ----------------首屏渲染----------------------------
function render(rootElement, rootDom) {
    console.log('------------first render-------------');
    const root = (0, reconcileElement_1.reconcileElement_concurrent)(rootElement); // 新老ele进行调和(生成element树 转换为二叉fiber树)
    // 注册首屏渲染后的钩子
    (0, concurrent_1.after_FirstReconcile_Hook)(() => {
        const beginWorkFiber = beginWork(root.fiber);
        const finishedWorkFiber = finishedWork(beginWorkFiber, null); // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了
        const rootFiber = scheduleFiber(finishedWorkFiber); // 调度fiber,根据优先级排序任务
        (0, commit_1.commitPart_First)(rootFiber); // commit阶段 一并更新dom
        console.log('首屏渲染生成的fiber', rootFiber);
    });
    return root;
}
exports.render = render;
//! ----------------综合updateRender方法-------------------
function updateRender(functionComponent, workInProgressFiber, currentFiber) {
    console.log('------------update render-------------');
    // 切换全局renderTag
    GlobalFiber_1.global.renderTag = 'update';
    //更新render时需要先将fiber的数据重置  重新挂载数据
    resetFiber(workInProgressFiber);
    resetFiber(currentFiber);
    // 更换workinProgress树 链接到当前vdom上
    connectElementAndWorkInProgress(workInProgressFiber);
    // 生成新的element树
    const newRootElement = (0, createElement_1.createElement)(functionComponent);
    const oldRootElement = currentFiber._element;
    const { newEle } = (0, reconcile_update_1.updateReconcileElement)(newRootElement, oldRootElement); // 新老ele进行调和(生成element树 转换为二叉fiber树)
    const beginWorkFiber = beginWork(newEle.fiber); // 遍历fiber树,根据effectTag执行对应操作(更新)
    const finishedWorkFiber = finishedWork(beginWorkFiber, null); // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了
    const rootFiber = scheduleFiber(finishedWorkFiber); // 调度fiber,根据优先级排序任务
    (0, commit_1.commitPart_Update)(rootFiber); // commit阶段 一并更新dom
}
exports.updateRender = updateRender;
