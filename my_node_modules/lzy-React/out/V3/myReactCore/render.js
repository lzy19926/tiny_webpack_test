"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.unmountAtRoot = exports.renderRoute = exports.updateRender = exports.render = void 0;
const Schedular_1 = require("./Schedular");
const GlobalFiber_1 = require("./GlobalFiber");
const concurrent_1 = require("./concurrent");
const commit_1 = require("./commit");
const renderWork_1 = require("../myJSX/renderWork");
const reconcile_update_1 = require("../myJSX/reconcile_update");
const createElement_1 = require("../myJSX/createElement");
const eventRegister_1 = require("../myEvent/eventRegister");
const logger_1 = require("../utils/logger");
//! ----------遍历fiber  收集effect 挂载到本次root节点 识别删除节点------------------
function finishedWork(workInProgressFiber, currentFiber) {
    // 遍历fiber树 将所有Effect添加进root节点的update环链表中
    const root = workInProgressFiber;
    let rootUpdateQueue = { firstEffect: null, lastEffect: null };
    finishedWorkLoop(workInProgressFiber, rootUpdateQueue, 'root');
    // 处理好的updateQueue成为到本次root节点的updateQueue
    root.updateQueue = rootUpdateQueue;
    return root;
}
//! 遍历fiber  拼接所有的effect
function finishedWorkLoop(workInProgressFiber, rootUpdateQueue, tag) {
    // 将updateQueue拼接到fiber的queue上
    collectEffect(workInProgressFiber, rootUpdateQueue);
    //diff两个节点 打上tag 生成Effect交给commit阶段更新
    // diffFiberNode(workInProgressFiber, null)
    // 继续遍历fiber树  拼接链表 深度优先递归执行
    const childFiber = workInProgressFiber._child;
    const siblingFiber = workInProgressFiber._sibling;
    if (childFiber) {
        finishedWorkLoop(childFiber, rootUpdateQueue);
    }
    if (siblingFiber && tag !== 'root') { // 第一次不进入组件节点的sibling
        finishedWorkLoop(siblingFiber, rootUpdateQueue);
    }
}
//! 将fiber的effect链表拼接起来
function collectEffect(fiber, rootUpdateQueue) {
    if (!fiber)
        return;
    const fiberUpdateQueue = fiber.updateQueue;
    if (fiberUpdateQueue && fiberUpdateQueue.lastEffect) {
        const first = fiberUpdateQueue.lastEffect.next;
        const last = fiberUpdateQueue.lastEffect;
        if (rootUpdateQueue.lastEffect) {
            rootUpdateQueue.lastEffect.next = first;
            rootUpdateQueue.lastEffect = last;
            last.next = rootUpdateQueue.firstEffect;
        }
        else {
            rootUpdateQueue.firstEffect = first;
            rootUpdateQueue.lastEffect = last;
        }
    }
}
//TODO--- 进行优先级排序
function scheduleFiber(workInProgressFiber) {
    return workInProgressFiber;
}
//遍历清空fiber树上的hookIndex 和 queue 和 EffectTag
function resetFiber(fiber) {
    if (!fiber)
        return;
    fiber.hookIndex = 0;
    fiber.updateQueue = null;
    fiber.effectTag = undefined;
    GlobalFiber_1.global.EffectList = { firstEffect: null, lastEffect: null, length: 0 };
    GlobalFiber_1.global.destoryEffectsArr = [];
    if (fiber._child) {
        resetFiber(fiber._child);
    }
    if (fiber._sibling) {
        resetFiber(fiber._sibling);
    }
}
//!-------- 切换当前的workInprogress树  链接到当前element树上--------------
function connectElementAndWorkInProgress(workInProgressFiber) {
    const element = workInProgressFiber._element;
    element.fiber = workInProgressFiber;
    if (workInProgressFiber._child) {
        connectElementAndWorkInProgress(workInProgressFiber._child);
    }
    if (workInProgressFiber._sibling) {
        connectElementAndWorkInProgress(workInProgressFiber._sibling);
    }
}
// 遍历fiber树,根据effectTag执行对应操作(更新)
function beginWork(workInProgressFiber) {
    (0, Schedular_1.markRef)(workInProgressFiber);
    beginWorkUpdate(workInProgressFiber);
    (0, Schedular_1.scheduleFiberNode)(workInProgressFiber);
    if (workInProgressFiber._child) {
        beginWork(workInProgressFiber._child);
    }
    if (workInProgressFiber._sibling) {
        beginWork(workInProgressFiber._sibling);
    }
    return workInProgressFiber;
}
//  不同类型的fiberNode执行不同的更新(更新后进行reconcile)
function beginWorkUpdate(workInProgressFiber) {
    const fiberType = workInProgressFiber.nodeType;
    switch (fiberType) {
        //todo 函数组件 处理effects链表
        case 'FunctionComponent':
            updateFunctionComponent(workInProgressFiber);
            break;
        //todo App根组件 处理effects链表
        case 'AppNode':
            updateAppNode(workInProgressFiber);
            break;
        //todo dom节点  执行dom更新操作
        case 'HostComponent':
            updateHostComponent(workInProgressFiber);
            break;
        //todo text节点 单独更新
        case 'HostText':
            updateHostText(workInProgressFiber);
            break;
        //todo ForwardRef类型节点处理
        case "ForwardRef":
            updateForwardRef(workInProgressFiber);
        default:
            break;
    }
}
function updateFunctionComponent(wk) { }
function updateAppNode(wk) { }
function updateHostComponent(wk) { }
function updateHostText(wk) { }
function updateForwardRef(wk) {
    // 该函数主要是解除传递ref的限制 (检测到是forwardRef节点)
    // 对函数组件,会限制ref的传递
}
//! ----------------首屏渲染----------------------------
function render(rootElement, rootDom, options) {
    initOptions(options);
    logger_1.logger.log('------------first render-------------');
    (0, eventRegister_1.startSyntheticEventSystem)(rootDom); //开启合成事件系统
    const containerFiber = (0, renderWork_1.createContainerFiber)(rootDom);
    const root = (0, renderWork_1.renderWork_concurrent)(rootElement, containerFiber); // 新老ele进行调和(生成element树 转换为二叉fiber树)
    // 注册首屏渲染后的钩子
    (0, concurrent_1.after_FirstReconcile_Hook)(() => {
        const beginWorkFiber = beginWork(root.fiber);
        const finishedWorkFiber = finishedWork(beginWorkFiber, null); // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了
        const rootFiber = scheduleFiber(finishedWorkFiber); // 调度fiber,根据优先级排序任务
        (0, commit_1.commitPart_First)(rootFiber); // commit阶段 一并更新dom
        logger_1.logger.log('首屏渲染生成的fiber', rootFiber);
    });
    return root;
}
exports.render = render;
//! ----------------综合updateRender方法-------------------
function updateRender(functionComponent, workInProgressFiber, currentFiber) {
    logger_1.logger.log('------------update render-------------');
    // 切换全局renderTag
    GlobalFiber_1.global.renderTag = 'update';
    //更新render时需要先将fiber的数据重置  重新挂载数据
    resetFiber(workInProgressFiber);
    resetFiber(currentFiber);
    // 更换workinProgress树 链接到当前vdom上
    connectElementAndWorkInProgress(workInProgressFiber);
    // 生成新的element树
    const newRootElement = (0, createElement_1.createElement)(functionComponent);
    const oldRootElement = currentFiber._element;
    // 更新的根节点需要继承老节点的props(否则内层更新props会丢失)
    newRootElement.props = oldRootElement.props;
    const { newEle } = (0, reconcile_update_1.updateReconcileElement)(newRootElement, oldRootElement); // 新老ele进行调和(生成element树 转换为二叉fiber树)
    const beginWorkFiber = beginWork(newEle.fiber); // 遍历fiber树,根据effectTag执行对应操作(更新)
    const finishedWorkFiber = finishedWork(beginWorkFiber, null); // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了
    const rootFiber = scheduleFiber(finishedWorkFiber); // 调度fiber,根据优先级排序任务
    (0, commit_1.commitPart_Update)(rootFiber); // commit阶段 一并更新dom
}
exports.updateRender = updateRender;
//! -------------------渲染路由页面------------------
function renderRoute(rootElement, containerFiber) {
    //需要先清空之前的effectList
    GlobalFiber_1.global.EffectList = { firstEffect: null, lastEffect: null, length: 0 };
    //清空路由内部元素
    containerFiber._child = undefined;
    containerFiber.stateNode.innerHTML = null;
    const root = (0, renderWork_1.renderWork_concurrent)(rootElement, containerFiber); // 新老ele进行调和(生成element树 转换为二叉fiber树)
    // 注册首屏渲染后的钩子
    (0, concurrent_1.after_FirstReconcile_Hook)(() => {
        const beginWorkFiber = beginWork(root.fiber);
        const finishedWorkFiber = finishedWork(beginWorkFiber, null); // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了
        const rootFiber = scheduleFiber(finishedWorkFiber); // 调度fiber,根据优先级排序任务
        (0, commit_1.commitPart_First)(rootFiber); // commit阶段 一并更新dom
        logger_1.logger.log('路由渲染渲染生成的fiber', rootFiber);
    });
    return root;
}
exports.renderRoute = renderRoute;
//TODO 卸载应用方法
function unmountAtRoot(rootDom) {
    rootDom.innerHTML = null;
    GlobalFiber_1.global.workInprogressFiberNode = null;
    GlobalFiber_1.global.workInProgressHook = { currentHook: null };
    GlobalFiber_1.global.EffectList = { firstEffect: null, lastEffect: null, length: 0 };
    GlobalFiber_1.global.LayoutEffectList = { firstEffect: null, lastEffect: null, length: 0 };
    GlobalFiber_1.global.destoryEffectsArr = [];
    GlobalFiber_1.global.renderTag = 'mount';
    GlobalFiber_1.global.isFirstRenderDone = false;
}
exports.unmountAtRoot = unmountAtRoot;
// 初始化配置
function initOptions(options) {
    if (!options)
        return;
    options.openLogger && logger_1.logger.open();
}
