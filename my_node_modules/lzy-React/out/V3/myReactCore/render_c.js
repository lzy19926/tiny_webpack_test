"use strict";
//1.  生成element树，转换为二叉fiber,保存fiber进map
Object.defineProperty(exports, "__esModule", { value: true });
exports.render = void 0;
//2.  生成新element树,查找map,有可复用的节点拿过来, 没有的打上标记添加,  map剩余的删除
const Schedular_1 = require("./Schedular");
const concurrent_1 = require("./concurrent");
const commit_1 = require("./commit");
const reconcileElement_1 = require("../myJSX/reconcileElement");
//! ----------遍历fiber  收集effect 挂载到本次root节点 识别删除节点------------------
function finishedWork(workInProgressFiber, currentFiber) {
    // 遍历fiber树 将所有Effect添加进root节点的update环链表中
    const root = workInProgressFiber;
    let rootUpdateQueue = { lastEffect: null };
    finishedWorkLoop(workInProgressFiber, rootUpdateQueue);
    // 处理好的updateQueue成为到本次root节点的updateQueue
    root.updateQueue = rootUpdateQueue;
    return root;
}
//! 遍历fiber  拼接所有的effect   
function finishedWorkLoop(workInProgressFiber, rootUpdateQueue) {
    // 将updateQueue拼接到fiber的queue上
    collectEffect(workInProgressFiber, rootUpdateQueue);
    //diff两个节点 打上tag 生成Effect交给commit阶段更新
    (0, Schedular_1.diffFiberNode)(workInProgressFiber, null);
    // 继续遍历fiber树  拼接链表 深度优先递归执行
    const childFiber = workInProgressFiber._child;
    const siblingFiber = workInProgressFiber._sibling;
    if (childFiber) {
        finishedWorkLoop(childFiber, rootUpdateQueue);
    }
    if (siblingFiber) {
        finishedWorkLoop(siblingFiber, rootUpdateQueue);
    }
}
//! 将fiber的effect链表拼接到
function collectEffect(fiber, rootUpdateQueue) {
    if (!fiber)
        return;
    const fiberUpdateQueue = fiber.updateQueue;
    if (fiberUpdateQueue && fiberUpdateQueue.lastEffect) {
        rootUpdateQueue.lastEffect = fiberUpdateQueue.lastEffect;
        fiberUpdateQueue.lastEffect.next = rootUpdateQueue.lastEffect.next;
    }
}
//TODO--- 进行优先级排序
function scheduleFiber(workInProgressFiber) {
    return workInProgressFiber;
}
//! ----------------首屏渲染----------------------------
function render(rootElement, rootDom) {
    console.log('------------first render-------------');
    const root = (0, reconcileElement_1.reconcileElement_concurrent)(rootElement); //这里分为begin finishwork两部分遍历  这里拆分出来
    // 注册首屏渲染后的钩子
    (0, concurrent_1.after_FirstReconcile_Hook)(() => {
        const beginWorkFiber = root.fiber;
        const finishedWorkFiber = finishedWork(beginWorkFiber, null); // 从下往上遍历fiber收集所有的Effects 形成链表 上传递优先级给root 这里finishedWork应该在renderPart中  这里拆分出来了
        const rootFiber = scheduleFiber(finishedWorkFiber); // 调度fiber,根据优先级排序任务
        (0, commit_1.commitPart_First)(rootFiber); // commit阶段
        console.log('首屏渲染生成的fiber', rootFiber);
    });
    return root;
}
exports.render = render;
