"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.myUseImperativeHandle = void 0;
const logger_1 = require("../utils/logger");
const useEffect_1 = require("./useEffect");
/*******************************************************************************************
 * myUseImperativeHandle的核心逻辑
 * 执行传入的create函数,生成instance挂载到ref.current上(此时已经给dom绑定了ref)
 * 返回一个destroy函数, 删除ref.current,
 * *****************************************************************************************/
//TODO 注意,执行这个create函数时,ref已经被赋值,故应该是使用useLayoutEffect实现
//TODO2 当前为dom节点绑定ref是在layoutMutation阶段实现,应将其挪到commit mutation阶段
//使用useEffect会导致执行此函数时ref内还未挂载dom
function myUseImperativeHandleImpl(ref, create) {
    const instance = create();
    if (typeof ref === 'function') {
        ref(instance);
        return () => {
            ref(null);
        };
    }
    else {
        ref.current = instance;
        return () => {
            ref.current = null;
        };
    }
}
/*******************************************************************************************
 * 该Hook的复用useEffect的逻辑, 通过effect队列执行create/destroy函数,并在dep变更时重新执行
 * 将myUseImperativeHandleImpl作为create函数执行,返回destroy函数
 * *****************************************************************************************/
function myUseImperativeHandle(ref, create, deps) {
    if (typeof create !== 'function') {
        return logger_1.logger.error('myUseImperativeHandle()的二号参数应当是一个函数');
    }
    if (ref === null && ref === undefined) {
        return logger_1.logger.log('myUseImperativeHandle()未接收到ref');
    }
    //todo 应使用useLayoutEffect,此时ref已经有值,不会起冲突
    return (0, useEffect_1.myUseEffect)(myUseImperativeHandleImpl.bind(null, ref, create), deps);
}
exports.myUseImperativeHandle = myUseImperativeHandle;
