"use strict";
/*******************************************************************************************
 * 将element包裹一层,作为FORWARD_REF_TYPE类型节点
 * 于markRef的时候记录ref
 * 在render阶段创建fiber节点时(createFiberAndConnect)， 将该类型节点的render函数取出执行,注入ref
 * 而普通的函数组件,markRef的时候会阻止ref的传递, (由于ref只能绑定给dom节点)
 * 这个API只做了一件事,将组件函数包装为FORWARD_REF_TYPE,后续按照forwardRef处理
 * *****************************************************************************************/
Object.defineProperty(exports, "__esModule", { value: true });
exports.forwardRef = void 0;
const elementType_1 = require("../myJSX/elementType");
function forwardRef(render) {
    if (typeof render !== 'function') {
        console.error('forwardRef 需要接收一个函数组件');
    }
    if (render.length !== 2) {
        console.error('forwardRef 内的函数组件需要传递两个参数 props,ref');
    }
    //@ts-ignore
    if ((render === null || render === void 0 ? void 0 : render.$$typeof) === elementType_1.MEMO_TYPE) {
        console.error(`
    forwardRef 无法处理Memo函数,
    请使用memo(forwardRef(...))代替forwardRef(memo(...))
    `);
    }
    const newElementType = {
        $$typeof: Symbol.for(elementType_1.FORWARD_REF_TYPE),
        render
    };
    return newElementType;
}
exports.forwardRef = forwardRef;
