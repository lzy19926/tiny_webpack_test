"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.flatArray = exports.isContextProvider = exports.isFunctionElement = exports.isElement = exports.isKey = exports.hasKey = exports.getParentDom = exports.isHTMLElement = exports.insertAfter = exports.updateWorkInProgressHook = exports.findPrevSiblingFiber = exports.isEmpty = void 0;
const kindOf_1 = require("./kindOf");
// 判断是否为空值
function isEmpty(value) {
    return typeof value === 'undefined' || value === null;
}
exports.isEmpty = isEmpty;
// 找到上一个兄弟节点
function findPrevSiblingFiber(fiber) {
    const parentFiber = fiber._parent;
    if (!parentFiber)
        return undefined;
    if (parentFiber._child === fiber)
        return undefined;
    let prev;
    let current = parentFiber._child;
    while (current !== fiber) {
        prev = current;
        current = current._sibling;
    }
    return prev;
}
exports.findPrevSiblingFiber = findPrevSiblingFiber;
//! ----------拿取需要本次update需要更新的hook----------------------
function updateWorkInProgressHook(fiber) {
    let index = fiber.hookIndex;
    let currentHook = fiber.memorizedState;
    while (currentHook && currentHook.index != index) {
        currentHook = currentHook.next;
    }
    // 因为链表是按顺序的 所以这个函数每执行一次就新增一个
    fiber.hookIndex += 1;
    return currentHook;
}
exports.updateWorkInProgressHook = updateWorkInProgressHook;
// 插入dom到某个dom节点后
function insertAfter(newDom, targetDom) {
    let parDom = targetDom.parentNode;
    let lastDom = parDom.lastChild;
    if (lastDom === targetDom) {
        parDom.appendChild(newDom);
    }
    else {
        let nextDom = targetDom.nextSibling;
        parDom.insertBefore(newDom, nextDom);
    }
}
exports.insertAfter = insertAfter;
// 判断是否是DOM对象
function isHTMLElement(obj) {
    return (typeof HTMLElement === 'object')
        ? obj instanceof HTMLElement
        : obj && typeof obj === 'object' && obj.nodeType === 1 && typeof obj.nodeName === 'string';
}
exports.isHTMLElement = isHTMLElement;
// ----------向上找到父dom节点---------------------
function getParentDom(fiber) {
    let parentNode = fiber;
    let parentDom;
    if (!parentNode) {
        return document.getElementById('root');
    }
    // 如果是function或者provider
    while (!isHTMLElement(parentDom)) {
        parentNode = parentNode._parent;
        if (!parentNode) {
            return document.getElementById('root');
        }
        parentDom = parentNode.stateNode;
    }
    return parentDom;
}
exports.getParentDom = getParentDom;
// ---------校验key值--------------
function hasKey(element) {
    if (element.key.toString().split('_')[0] === 'key') {
        return false;
    }
    return typeof element.key !== 'undefined' && element.key !== null;
}
exports.hasKey = hasKey;
// ---------校验key值--------------
function isKey(key) {
    return typeof key !== 'undefined' && key !== null;
}
exports.isKey = isKey;
// 判断是否为Element
function isElement(node) {
    if (!node.$$typeof)
        return false;
    return Symbol.keyFor(node.$$typeof) === 'lzyElement';
}
exports.isElement = isElement;
function isFunctionElement(ele) {
    var _a;
    return ele.tag && ele.tag[0] === ((_a = ele.tag) === null || _a === void 0 ? void 0 : _a[0].toUpperCase());
}
exports.isFunctionElement = isFunctionElement;
// 判断是否为ContextProvider
function isContextProvider(ele) {
    const t = ele.$$typeof;
    return (0, kindOf_1.kindOf)(t) === 'symbol' &&
        Symbol.keyFor(t) === 'lzyContextProviderElement';
}
exports.isContextProvider = isContextProvider;
// 递归-数组扁平化
function flatArray(arr, resultArr = []) {
    for (const item of arr) {
        if (Array.isArray(item)) {
            flatArray(item, resultArr);
        }
        else {
            resultArr.push(item);
        }
    }
    return resultArr;
}
exports.flatArray = flatArray;
