"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.createAlternate = exports.createFiber = exports.createFiberTree_concurrent = exports.reconcileElement = void 0;
const GlobalFiber_1 = require("../myReactCore/GlobalFiber");
const createElement_1 = require("../myJSX/createElement");
const concurrent_1 = require("../myReactCore/concurrent");
// 遍历element树,创建二叉fiber树
function reconcileElement(rootElement) {
}
exports.reconcileElement = reconcileElement;
//! ------------初始创建fiberTree-------------------
function createFiberTree_concurrent(rootElement) {
    //todo------- 遍历二叉element树----
    const stack = [];
    let current;
    let currentAlt;
    let rootFiber;
    let rootFiberAlt;
    // 创建App节点
    rootFiber = current = createRootFiber(rootElement);
    rootFiberAlt = currentAlt = createAlternate(current);
    // 从App的child开始遍历
    if (rootElement._child)
        stack.push({
            from: 'child',
            fromFiber: rootFiber,
            fromFiberAlt: rootFiberAlt,
            elementNode: rootElement._child,
            parentFiber: rootFiber
        });
    // 将 render的while循环遍历fiberTree的逻辑切片执行
    const getCondition = () => stack.length > 0;
    (0, concurrent_1.concurrentWhile)(getCondition, () => {
        // 根据element创建一个fiber以及它的alternate
        //  stack.pop()为此时遍历到的element   执行处理逻辑
        let { from, fromFiber, fromFiberAlt, elementNode, parentFiber } = stack.pop();
        current = createFiber(elementNode, parentFiber);
        currentAlt = createAlternate(current);
        // 链接前后fiber和alternateFiber
        if (from === 'child') {
            fromFiber._child = current;
            fromFiberAlt._child = currentAlt;
        }
        else if (from === 'sibling') {
            fromFiber._sibling = current;
            fromFiberAlt._sibling = currentAlt;
        }
        // 将下一个节点入栈 继续遍历 (注意这里childElement的声明要放在后面,否则可能会保存为undefined)
        let childElement = elementNode._child;
        let siblingElement = elementNode._sibling;
        if (siblingElement) {
            stack.push({
                from: 'sibling',
                fromFiber: current,
                fromFiberAlt: currentAlt,
                elementNode: elementNode._sibling,
                parentFiber: parentFiber
            });
        }
        if (childElement) {
            stack.push({
                from: 'child',
                fromFiber: current,
                fromFiberAlt: currentAlt,
                elementNode: elementNode._child,
                parentFiber: current
            });
        }
        //执行后续操作
        if (!getCondition()) {
            concurrent_1.concurrentWhileHook.afterFirstRender();
        }
    });
    return rootFiber;
}
exports.createFiberTree_concurrent = createFiberTree_concurrent;
//!------ 单独处理创建AppFiber节点
function createRootFiber(rootElement) {
    let rootFiber = new GlobalFiber_1.FiberNode('mount', '$1');
    GlobalFiber_1.global.workInprogressFiberNode = rootFiber; //todo 切换当前工作fiber
    // 首先创建rootFiber(单独处理app节点) 
    const childElementTree = rootElement.ref.call(undefined, rootElement.props); //! 挂载props
    rootElement._child = (0, createElement_1.transformElementTreeToBinadyTree)(childElementTree, rootElement); //! 重新生成新的二叉element树
    rootFiber.tag = rootElement.tag;
    rootFiber._element = rootElement;
    rootElement.fiber = rootFiber;
    rootFiber.nodeType = 'AppNode';
    rootFiber.stateNode = rootElement.ref;
    rootFiber.fiberFlags = 'update';
    return rootFiber;
}
//!------ 创建单个fiber节点
function createFiber(elementNode, parentFiber) {
    // 创建newFiber
    let newFiberNode = new GlobalFiber_1.FiberNode('mount', '$1');
    // 切换当前工作fiber
    GlobalFiber_1.global.workInprogressFiberNode = newFiberNode;
    // 给fiber赋值 并链接parent
    newFiberNode._parent = parentFiber;
    newFiberNode.tag = elementNode.tag;
    newFiberNode._element = elementNode;
    elementNode.fiber = newFiberNode;
    //如果tag大写 解析为FC组件节点 重新生成element  挂载props
    if (elementNode.tag[0] === elementNode.tag[0].toUpperCase()) {
        newFiberNode.nodeType = 'FunctionComponent';
        newFiberNode.stateNode = elementNode.ref;
        const childElementTree = elementNode.ref.call(undefined, elementNode.props); //! 挂载props
        elementNode._child = (0, createElement_1.transformElementTreeToBinadyTree)(childElementTree, elementNode); //! 重新生成新的二叉element树
    }
    //解析为text节点
    else if (elementNode.tag === 'text') {
        newFiberNode.nodeType = 'HostText';
        newFiberNode.text = elementNode.text;
    }
    //解析为普通dom节点
    else {
        newFiberNode.nodeType = 'HostComponent';
    }
    // 更改状态
    newFiberNode.fiberFlags = 'update';
    return newFiberNode;
}
exports.createFiber = createFiber;
// 创建单个alt
function createAlternate(currentFiber) {
    let alternateFiber = new GlobalFiber_1.FiberNode('mount', '$2');
    //! 将一些属性复制给workInProgress
    alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer;
    alternateFiber.updateQueue = currentFiber.updateQueue;
    alternateFiber.hookIndex = currentFiber.hookIndex;
    alternateFiber.memorizedState = currentFiber.memorizedState;
    alternateFiber.nodeType = currentFiber.nodeType;
    alternateFiber.tag = currentFiber.tag;
    alternateFiber.text = currentFiber.text;
    //! 链接两个fiber 
    alternateFiber.alternate = currentFiber;
    currentFiber.alternate = alternateFiber;
    //! 链接parent
    if (currentFiber._parent) {
        alternateFiber._parent = currentFiber._parent.alternate;
        currentFiber._parent.alternate = alternateFiber._parent;
    }
    // 更改状态
    alternateFiber.fiberFlags = 'update';
    return alternateFiber;
}
exports.createAlternate = createAlternate;
