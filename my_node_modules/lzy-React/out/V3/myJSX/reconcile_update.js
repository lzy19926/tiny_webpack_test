"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateReconcileElement = void 0;
const GlobalFiber_1 = require("../myReactCore/GlobalFiber");
const elementType_1 = require("../myJSX/elementType");
const reconcileElement_1 = require("./reconcileElement");
const utils_1 = require("../utils/utils");
// 浅比较两个节点是否相同 可复用
function shallowCompareElement(newEle, oldEle) {
    return (((newEle === null || newEle === void 0 ? void 0 : newEle.key) === (oldEle === null || oldEle === void 0 ? void 0 : oldEle.key))
        && ((newEle === null || newEle === void 0 ? void 0 : newEle.tag) === (oldEle === null || oldEle === void 0 ? void 0 : oldEle.tag))
        && ((newEle === null || newEle === void 0 ? void 0 : newEle.key) === (oldEle === null || oldEle === void 0 ? void 0 : oldEle.key)));
}
// 同步添加fiber树
function placementFiber(rootElement, parentFiber, prevSibling) {
    // 创建
    let workInProgressFiber = reconcileElement(rootElement).fiber;
    // 切换$
    if (workInProgressFiber.$fiber !== parentFiber.$fiber) {
        workInProgressFiber = workInProgressFiber.alternate;
    }
    // 链接
    workInProgressFiber._parent = parentFiber;
    workInProgressFiber.alternate._parent = parentFiber.alternate;
    rootElement.fiber = workInProgressFiber;
    workInProgressFiber._element = rootElement;
    workInProgressFiber.alternate._element = rootElement;
    if (prevSibling) {
        const prevSiblingFiber = prevSibling.fiber;
        const nextSibling = prevSiblingFiber._sibling;
        prevSiblingFiber._sibling = workInProgressFiber;
        prevSiblingFiber.alternate._sibling = workInProgressFiber.alternate;
        if (nextSibling) {
            workInProgressFiber._sibling = nextSibling;
            workInProgressFiber.alternate._sibling = nextSibling.alternate;
        }
    }
}
// 同步创建fiber树
function reconcileElement(rootElement, parentFiber, prevSibling) {
    if (!rootElement)
        return;
    let stack = [];
    stack.push({ element: rootElement, parentFiber, prevSibling, });
    while (stack.length > 0) {
        const { element, parentFiber, prevSibling } = stack.pop();
        const prevSiblingFiber = prevSibling === null || prevSibling === void 0 ? void 0 : prevSibling.fiber; // 此时siblingFiber已经生成 从element指针中拿出siblingFiber
        const workInProgressFiber = (0, reconcileElement_1.createFiberAndConnect)(element, parentFiber, prevSiblingFiber);
        // 继续执行
        if (element.children && element.children.length > 0) {
            let i = element.children.length - 1;
            for (i; i >= 0; i--) {
                stack.push({
                    element: element.children[i],
                    parentFiber: workInProgressFiber,
                    prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
                });
            }
        }
    }
    return rootElement;
}
function updateReconcileElement(newEle, oldEle) {
    // 新vnode和老vnode进行对比
    const isSameNode = shallowCompareElement(newEle, oldEle);
    if (!isSameNode)
        return { isSameNode, newEle };
    if (isSameNode) {
        // 直接打标记更新该节点的wk
        const workInProgressFiber = oldEle.fiber;
        // 变更当前工作节点
        GlobalFiber_1.global.workInprogressFiberNode = workInProgressFiber;
        workInProgressFiber.effectTag = 'Update';
        // 链接到当前vnode(双fiber同时链接到newEle)
        newEle.fiber = workInProgressFiber;
        workInProgressFiber._element = newEle;
        workInProgressFiber.alternate._element = newEle;
    }
    // 继续向下 组件vnode   挂载props,children和fiber
    if ((0, elementType_1.isFunctionEle)(newEle)) {
        const childElement = newEle.ref.call(undefined, newEle.props, newEle.children, newEle.fiber);
        newEle.children = [childElement];
    }
    if (newEle.children && newEle.children.length > 0) {
        let i = 0;
        while (i < newEle.children.length) {
            const newChild = newEle.children[i];
            const oldChild = oldEle.children[i];
            const { isSameNode } = updateReconcileElement(newChild, oldChild);
            if (!isSameNode)
                break;
            i++;
        }
        // 老fiber生成map
        const fiberMap = new Map();
        oldEle.children.forEach((oldChild) => {
            if ((0, utils_1.hasKey)(oldChild)) {
                fiberMap.set(oldChild.key, oldChild.fiber);
            }
        });
        if (i <= newEle.children.length) {
            // 遍历处理后续未处理的newEle节点
            for (let k = i; k < newEle.children.length; k++) {
                let newChildEle = newEle.children[k];
                // map中找到则拿来复用
                if ((0, utils_1.hasKey)(newChildEle) && fiberMap.has(newChildEle.key)) {
                    const workInProgressFiber = fiberMap.get(newChildEle.key);
                    // 变更当前工作节点
                    GlobalFiber_1.global.workInprogressFiberNode = workInProgressFiber;
                    console.log('复用fiber', workInProgressFiber);
                    // 拼接后从map中删除
                    fiberMap.delete(newChildEle.key);
                }
                // map中未找到 且有key说明需要添加节点
                else if ((0, utils_1.hasKey)(newChildEle) && !fiberMap.has(newChildEle.key)) {
                    const siblingBefore = newEle.children[k - 1];
                    console.log('添加节点', newChildEle, newEle.fiber, siblingBefore); // 正确
                    placementFiber(newChildEle, newEle.fiber, siblingBefore);
                }
                // 其余无key的节点
                else {
                    const reIndexNew = newEle.children.length - 1 - k;
                    const indexOld = oldEle.children.length - 1 - reIndexNew;
                    const oldChildEle = oldEle.children[indexOld];
                    updateReconcileElement(newChildEle, oldChildEle);
                }
            }
        }
        // 新fiber从map中删除
        newEle.children.forEach((newChild) => {
            fiberMap.delete(newChild.key);
        });
        // 遍历map中剩余的fiber,打上删除tag
        fiberMap.forEach((fiber) => {
            fiber.effectTag = 'Delete';
        });
    }
    return { isSameNode, newEle };
}
exports.updateReconcileElement = updateReconcileElement;
