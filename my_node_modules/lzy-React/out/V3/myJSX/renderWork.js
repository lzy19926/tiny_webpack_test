"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.renderWork_concurrent = exports.renderElement = exports.createContainerFiber = void 0;
const GlobalFiber_1 = require("../myReactCore/GlobalFiber");
const concurrent_1 = require("../myReactCore/concurrent");
const elementType_1 = require("./elementType");
const logger_1 = require("../utils/logger");
// --创建基础Fiber节点
function createBaseFiberNode(elementNode, parentFiber) {
    // 创建newFiber
    let newFiberNode = new GlobalFiber_1.FiberNode('mount', '$1');
    // 切换当前工作fiber
    GlobalFiber_1.global.workInprogressFiberNode = newFiberNode;
    // 给fiber赋值 并链接parent
    newFiberNode._parent = parentFiber;
    newFiberNode.tag = elementNode.tag;
    newFiberNode._element = elementNode;
    newFiberNode.effectTag = 'Placement';
    elementNode.fiber = newFiberNode;
    return newFiberNode;
}
// 创建单个alt
function createAlternate(currentFiber) {
    let alternateFiber = new GlobalFiber_1.FiberNode('mount', '$2');
    //! 将一些属性复制给workInProgress
    alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer;
    alternateFiber.updateQueue = currentFiber.updateQueue;
    alternateFiber.hookIndex = currentFiber.hookIndex;
    alternateFiber.memorizedState = currentFiber.memorizedState;
    alternateFiber.nodeType = currentFiber.nodeType;
    alternateFiber.effectTag = currentFiber.effectTag;
    alternateFiber.tag = currentFiber.tag;
    alternateFiber.text = currentFiber.text;
    alternateFiber.stateNode = currentFiber.stateNode;
    alternateFiber._element = currentFiber._element;
    //! 链接两个fiber
    alternateFiber.alternate = currentFiber;
    currentFiber.alternate = alternateFiber;
    //! 链接parent
    if (currentFiber._parent) {
        alternateFiber._parent = currentFiber._parent.alternate;
        currentFiber._parent.alternate = alternateFiber._parent;
    }
    return alternateFiber;
}
// --链接父,兄fiber节点
function linkParentAndSiblingFiberNode(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    if (parentFiber) {
        workInProgressFiber._parent = parentFiber;
        workInProgressFiber.alternate._parent = parentFiber === null || parentFiber === void 0 ? void 0 : parentFiber.alternate;
    }
    if (prevSibling) {
        prevSibling._sibling = workInProgressFiber;
        prevSibling.alternate._sibling = workInProgressFiber.alternate;
    }
    else if (parentFiber && !prevSibling) {
        parentFiber._child = workInProgressFiber;
        parentFiber.alternate._child = workInProgressFiber.alternate;
    }
    return workInProgressFiber;
}
// --执行带有hook的函数式组件
function renderWithHook(elementNode) {
    let childElement;
    // 执行函数组件
    if ((0, elementType_1.isFunctionEle)(elementNode)) {
        childElement = elementNode.render.call(undefined, elementNode.props, elementNode.children, elementNode.fiber);
    }
    // 执行forwardRef函数组件(将ref作为二号参数注入)
    else if ((0, elementType_1.isForwardRefEle)(elementNode)) {
        childElement = elementNode
            .render.call(undefined, elementNode.props, elementNode.ref, elementNode.children, elementNode.fiber);
    }
    elementNode.children = [childElement];
}
function mountFunctionComponent(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    workInProgressFiber.nodeType = 'FunctionComponent';
    workInProgressFiber.stateNode = elementNode.render;
    // 执行带有hook的函数式组件
    renderWithHook(elementNode);
    return workInProgressFiber;
}
function mountHostComponent(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    workInProgressFiber.nodeType = 'HostComponent';
    return workInProgressFiber;
}
function mountHostText(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    workInProgressFiber.nodeType = 'HostText';
    workInProgressFiber.text = elementNode.text;
    return workInProgressFiber;
}
function mountContextProvider(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    workInProgressFiber.nodeType = 'ContextProvider';
    return workInProgressFiber;
}
function mountForwardRef(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    workInProgressFiber.nodeType = 'ForwardRef';
    workInProgressFiber.stateNode = elementNode.render;
    // 执行带有hook的函数式组件
    renderWithHook(elementNode);
    return workInProgressFiber;
}
function mountMemoComponent(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    workInProgressFiber.nodeType = 'MemoComponent';
    return workInProgressFiber;
}
function warnUnknownComponent(entry) {
    const { elementNode, workInProgressFiber, parentFiber, prevSibling } = entry;
    workInProgressFiber.nodeType = 'UnknownType';
    logger_1.logger.warn("创建了未知类型的fiber节点");
}
//!------通过domContainer创建rootFiber
function createContainerFiber(domContainer) {
    let newFiberNode = new GlobalFiber_1.FiberNode('mount', '$1');
    GlobalFiber_1.global.workInprogressFiberNode = newFiberNode;
    newFiberNode.tag = domContainer.tagName;
    newFiberNode.nodeType = 'AppNode';
    newFiberNode.stateNode = domContainer;
    createAlternate(newFiberNode);
    newFiberNode.fiberFlags = 'update';
    newFiberNode.alternate.fiberFlags = 'update';
    return newFiberNode;
}
exports.createContainerFiber = createContainerFiber;
// 处理单个element节点,创建fiber,alternate并链接(并生成子elements)
function renderElement(elementNode, parentFiber, prevSibling) {
    const elementType = (0, elementType_1.getElementType)(elementNode);
    const workInProgressFiber = createBaseFiberNode(elementNode, undefined);
    const entry = {
        elementNode,
        workInProgressFiber,
        parentFiber,
        prevSibling
    };
    switch (elementType) {
        case elementType_1.ET.FUNCTION_COMPONENT:
            mountFunctionComponent(entry);
            break;
        case elementType_1.ET.HOST_COMPONENT:
            mountHostComponent(entry);
            break;
        case elementType_1.ET.HOST_TEXT:
            mountHostText(entry);
            break;
        case elementType_1.ET.CONTEXT__PROVIDER:
            mountContextProvider(entry);
            break;
        case elementType_1.ET.FORWARD_REF_TYPE:
            mountForwardRef(entry);
            break;
        case elementType_1.ET.MEMO_TYPE:
            mountMemoComponent(entry);
            break;
        default:
            warnUnknownComponent(entry);
            break;
    }
    //-- 创建alt(顺序不能乱)
    createAlternate(workInProgressFiber);
    linkParentAndSiblingFiberNode(entry);
    // 更改状态
    workInProgressFiber.fiberFlags = 'update';
    workInProgressFiber.alternate.fiberFlags = 'update';
    return workInProgressFiber;
}
exports.renderElement = renderElement;
//! ---- 通过rootElement,rootFiber逐步构建element树和fiber二叉树
// (使用栈算法分片执行)
function renderWork_concurrent(rootElement, parentFiber, prevSibling) {
    if (!rootElement)
        return;
    let stack = [];
    stack.push({ element: rootElement, parentFiber, prevSibling, });
    //! 栈算法分片执行
    const getCondition = () => stack.length > 0;
    (0, concurrent_1.concurrentWhile)(getCondition, () => {
        const { element, parentFiber, prevSibling } = stack.pop();
        const prevSiblingFiber = prevSibling === null || prevSibling === void 0 ? void 0 : prevSibling.fiber; // 此时siblingFiber已经生成 从element指针中拿出siblingFiber
        const workInProgressFiber = renderElement(element, parentFiber, prevSiblingFiber); //! 关键步骤
        // 继续执行
        if (element.children && element.children.length > 0) {
            let i = element.children.length - 1;
            for (i; i >= 0; i--) {
                stack.push({
                    element: element.children[i],
                    parentFiber: workInProgressFiber,
                    prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
                });
            }
        }
        // 执行结束回调
        if (!getCondition()) {
            const cb = concurrent_1.concurrentWhileHook.afterFirstReconcile;
            if (typeof cb === 'function') {
                cb();
            }
        }
    });
    return rootElement;
}
exports.renderWork_concurrent = renderWork_concurrent;
