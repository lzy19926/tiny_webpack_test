"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.updateReconcileElement = void 0;
const GlobalFiber_1 = require("../myReactCore/GlobalFiber");
const renderWork_1 = require("./renderWork");
const utils_1 = require("../utils/utils");
const logger_1 = require("../utils/logger");
// 浅比较两个节点是否相同 可复用
function shallowCompareElement(newEle, oldEle) {
    return (((newEle === null || newEle === void 0 ? void 0 : newEle.key) === (oldEle === null || oldEle === void 0 ? void 0 : oldEle.key))
        && ((newEle === null || newEle === void 0 ? void 0 : newEle.tag) === (oldEle === null || oldEle === void 0 ? void 0 : oldEle.tag))
        && ((newEle === null || newEle === void 0 ? void 0 : newEle.key) === (oldEle === null || oldEle === void 0 ? void 0 : oldEle.key)));
}
// 同步添加fiber树
function placementFiber(rootElement, parentFiber, prevSibling) {
    // 创建
    let workInProgressFiber = (0, renderWork_1.renderWork_sync)(rootElement).fiber;
    // 切换$
    if (workInProgressFiber.$fiber !== parentFiber.$fiber) {
        workInProgressFiber = workInProgressFiber.alternate;
    }
    // 链接
    workInProgressFiber._parent = parentFiber;
    workInProgressFiber.alternate._parent = parentFiber.alternate;
    rootElement.fiber = workInProgressFiber;
    workInProgressFiber._element = rootElement;
    workInProgressFiber.alternate._element = rootElement;
    if (prevSibling) {
        const prevSiblingFiber = prevSibling.fiber;
        const nextSibling = prevSiblingFiber._sibling;
        prevSiblingFiber._sibling = workInProgressFiber;
        prevSiblingFiber.alternate._sibling = workInProgressFiber.alternate;
        if (nextSibling) {
            workInProgressFiber._sibling = nextSibling;
            workInProgressFiber.alternate._sibling = nextSibling.alternate;
        }
    }
}
// 将workInProgressFiber从老ele上链接到新ele上,并变更当前全局工作节点
function switchWorkInProgressFiber(newEle, oldEle) {
    const workInProgressFiber = oldEle.fiber;
    GlobalFiber_1.global.workInprogressFiberNode = workInProgressFiber; // 变更当前工作节点
    newEle.fiber = workInProgressFiber;
    workInProgressFiber._element = newEle;
    workInProgressFiber.alternate._element = newEle; // 双fiber同时切换到newEle
    workInProgressFiber.effectTag = 'Update'; // 打上更新标记
}
function updateReconcileElement(newEle, oldEle) {
    // 新vnode和老vnode进行对比
    const isSameNode = shallowCompareElement(newEle, oldEle);
    if (!isSameNode)
        return { isSameNode, newEle };
    switchWorkInProgressFiber(newEle, oldEle); // 将wk挂载到newEle上
    //TODO 如果是函数组件, 继续向下执行函数组件(分节点拆分)
    (0, renderWork_1.renderWithHook)(newEle);
    if (newEle.children && newEle.children.length > 0) {
        let i = 0;
        while (i < newEle.children.length) {
            const newChild = newEle.children[i];
            const oldChild = oldEle.children[i];
            const { isSameNode } = updateReconcileElement(newChild, oldChild);
            if (!isSameNode)
                break;
            i++;
        }
        // 老fiber生成map
        const fiberMap = new Map();
        oldEle.children.forEach((oldChild) => {
            if ((0, utils_1.hasKey)(oldChild)) {
                fiberMap.set(oldChild.key, oldChild.fiber);
            }
        });
        if (i <= newEle.children.length) {
            // 遍历处理后续未处理的newEle节点
            for (let k = i; k < newEle.children.length; k++) {
                let newChildEle = newEle.children[k];
                // map中找到则拿来复用
                if ((0, utils_1.hasKey)(newChildEle) && fiberMap.has(newChildEle.key)) {
                    const workInProgressFiber = fiberMap.get(newChildEle.key);
                    // 变更当前工作节点
                    GlobalFiber_1.global.workInprogressFiberNode = workInProgressFiber;
                    logger_1.logger.log('复用fiber', workInProgressFiber);
                    // 拼接后从map中删除
                    fiberMap.delete(newChildEle.key);
                }
                // map中未找到 且有key说明需要添加节点
                else if ((0, utils_1.hasKey)(newChildEle) && !fiberMap.has(newChildEle.key)) {
                    const siblingBefore = newEle.children[k - 1];
                    logger_1.logger.log('添加节点', newChildEle, newEle.fiber, siblingBefore); // 正确
                    placementFiber(newChildEle, newEle.fiber, siblingBefore);
                }
                // 其余无key的节点
                else {
                    const reIndexNew = newEle.children.length - 1 - k;
                    const indexOld = oldEle.children.length - 1 - reIndexNew;
                    const oldChildEle = oldEle.children[indexOld];
                    updateReconcileElement(newChildEle, oldChildEle);
                }
            }
        }
        // 新fiber从map中删除
        newEle.children.forEach((newChild) => {
            fiberMap.delete(newChild.key);
        });
        // 遍历map中剩余的fiber,打上删除tag
        fiberMap.forEach((fiber) => {
            fiber.effectTag = 'Delete';
        });
    }
    return { isSameNode, newEle };
}
exports.updateReconcileElement = updateReconcileElement;
