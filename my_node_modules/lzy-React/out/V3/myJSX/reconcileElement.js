"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.reconcileElement_concurrent = exports.createFiberAndConnect = void 0;
const GlobalFiber_1 = require("../myReactCore/GlobalFiber");
const concurrent_1 = require("../myReactCore/concurrent");
//!------ 创建单个fiber节点
function createFiber(elementNode, parentFiber) {
    // 创建newFiber
    let newFiberNode = new GlobalFiber_1.FiberNode('mount', '$1');
    // 切换当前工作fiber
    GlobalFiber_1.global.workInprogressFiberNode = newFiberNode;
    // 给fiber赋值 并链接parent
    newFiberNode._parent = parentFiber;
    newFiberNode.tag = elementNode.tag;
    newFiberNode._element = elementNode;
    newFiberNode.effectTag = 'Placement';
    elementNode.fiber = newFiberNode;
    //如果tag大写 解析为FC组件节点 重新生成element  挂载props
    if (elementNode.tag[0] === elementNode.tag[0].toUpperCase()) {
        newFiberNode.nodeType = 'FunctionComponent';
        newFiberNode.stateNode = elementNode.ref;
    }
    //解析为text节点
    else if (elementNode.tag === 'text') {
        newFiberNode.nodeType = 'HostText';
        newFiberNode.text = elementNode.text;
    }
    //解析为普通dom节点
    else {
        newFiberNode.nodeType = 'HostComponent';
    }
    return newFiberNode;
}
// 创建单个alt
function createAlternate(currentFiber) {
    let alternateFiber = new GlobalFiber_1.FiberNode('mount', '$2');
    //! 将一些属性复制给workInProgress
    alternateFiber.stateQueueTimer = currentFiber.stateQueueTimer;
    alternateFiber.updateQueue = currentFiber.updateQueue;
    alternateFiber.hookIndex = currentFiber.hookIndex;
    alternateFiber.memorizedState = currentFiber.memorizedState;
    alternateFiber.nodeType = currentFiber.nodeType;
    alternateFiber.effectTag = currentFiber.effectTag;
    alternateFiber.tag = currentFiber.tag;
    alternateFiber.text = currentFiber.text;
    alternateFiber.stateNode = currentFiber.stateNode;
    alternateFiber._element = currentFiber._element;
    //! 链接两个fiber
    alternateFiber.alternate = currentFiber;
    currentFiber.alternate = alternateFiber;
    //! 链接parent
    if (currentFiber._parent) {
        alternateFiber._parent = currentFiber._parent.alternate;
        currentFiber._parent.alternate = alternateFiber._parent;
    }
    return alternateFiber;
}
// 遍历到的单个节点处理  创建并链接节点 同时创建alt
function createFiberAndConnect(element, parentFiber, prevSibling) {
    //--创建
    let workInProgressFiber = createFiber(element, undefined);
    // 组件vnode   挂载props 
    if (element.tag[0] === element.tag[0].toUpperCase()) {
        const childElement = element.ref.call(undefined, element.props);
        element.children = [childElement];
    }
    //-- 创建alt(顺序不能乱)
    const workInProgressFiber_alt = createAlternate(workInProgressFiber);
    // --链接
    if (parentFiber) {
        workInProgressFiber._parent = parentFiber;
        workInProgressFiber.alternate._parent = parentFiber === null || parentFiber === void 0 ? void 0 : parentFiber.alternate;
    }
    if (prevSibling) {
        prevSibling._sibling = workInProgressFiber;
        prevSibling.alternate._sibling = workInProgressFiber.alternate;
    }
    else if (parentFiber && !prevSibling) {
        parentFiber._child = workInProgressFiber;
        parentFiber.alternate._child = workInProgressFiber.alternate;
    }
    // 更改状态
    workInProgressFiber.fiberFlags = 'update';
    workInProgressFiber.alternate.fiberFlags = 'update';
    return workInProgressFiber;
}
exports.createFiberAndConnect = createFiberAndConnect;
//! ---- 通过rootElement创建二叉fiber树(切片)
// 通过传入parent,siblingBefore节点创建二叉树
// 通过栈将普通树的递归遍历转换为while循环, 再用切片while执行   
function reconcileElement_concurrent(rootElement, parentFiber, prevSibling) {
    if (!rootElement)
        return;
    let stack = [];
    stack.push({ element: rootElement, parentFiber, prevSibling, });
    //! 栈算法分片执行
    const getCondition = () => stack.length > 0;
    (0, concurrent_1.concurrentWhile)(getCondition, () => {
        const { element, parentFiber, prevSibling } = stack.pop();
        const prevSiblingFiber = prevSibling === null || prevSibling === void 0 ? void 0 : prevSibling.fiber; // 此时siblingFiber已经生成 从element指针中拿出siblingFiber
        const workInProgressFiber = createFiberAndConnect(element, parentFiber, prevSiblingFiber);
        // 继续执行
        if (element.children && element.children.length > 0) {
            let i = element.children.length - 1;
            for (i; i >= 0; i--) {
                stack.push({
                    element: element.children[i],
                    parentFiber: workInProgressFiber,
                    prevSibling: element.children[i - 1] // 先将element指针推入  此时还没生成fiber
                });
            }
        }
        // 执行结束回调
        if (!getCondition()) {
            concurrent_1.concurrentWhileHook.afterFirstReconcile();
        }
    });
    return rootElement;
}
exports.reconcileElement_concurrent = reconcileElement_concurrent;
