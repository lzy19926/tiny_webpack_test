const path = require('path')
const Koa = require('koa');
const WebSocket = require('ws')
const { DirectoryWatcher } = require('lzy-watchpack')
const MemoryFileSystem = require("memory-fs");
const SparkMD5 = require('spark-md5')
const staticResource = require('koa-static');

class WebpackDevServer {
    constructor(webpack) {
        this.webpack = webpack
        this.config = webpack.config
        this.app = undefined     // koa服务器
        this.watcher = undefined  // 文件监视系统
        this.wsConnection = undefined  // webSocket链接实例
        this.memoFs = new MemoryFileSystem()   // 内存文件系统
    }

    //TODO 开启koa后端服务  托管静态/内存资源
    // 这里模拟了一个动态资源服务器(staticResource是koa静态资源服务器,托管public下的文件  可以使用localhost:8080/index.html进行访问)
    // 下面的是模拟的资源服务器   当访问/bundle.js时  发送对应的数据给body  这也是静态资源托管的原理
    startServer() {
        const app = new Koa();

        app.use(staticResource(path.join(__dirname, 'public')))
        
        app.use(async (ctx) => {
            if (ctx.url === '/bundle.js') {
                ctx.set('Content-Type', 'application/javascript')
                ctx.body = this.memoFs.readFileSync("/memoStatic/bundle.js")
            }
            if (ctx.url === '/bundle.css') {
                ctx.set('Content-Type', 'text/css')
                ctx.body = this.memoFs.readFileSync("/memoStatic/bundle.css");
            }
        })

        app.listen(8080, () => {
            console.log('dev-server启动在8080端口');
        })

        this.app = app
    }

    //TODO 开启webSocket链接
    connectWebSocket() {
        //TODO 创建WebSocketServer到3001端口 (是一个独立的服务)
        //TODO 监听前后端链接事件  回调接收一个connection实例
        let that = this
        this.webSocket = new WebSocket.Server({ port: 3001 });
        this.webSocket.on('connection', function (wsConnection) {
            console.log('websocket连接成功,热更新准备就绪');
            const jsHash = that.caculateHash('/memoStatic/bundle.js')
            const cssHash = that.caculateHash('/memoStatic/bundle.css')
            const hash = jsHash + '-' + cssHash
            wsConnection.send(hash)
            console.log('本次热更新hash', hash);
            that.wsConnection = wsConnection
        });
    }

    //TODO 开启文件监视系统
    watchFiles() {
        //创建文件监视器
        const srcPath = path.resolve(this.config.entry, '..')
        this.watcher = new DirectoryWatcher({
            directoryList: [srcPath],
            poll: 1000
        })

        const isDep = (path) => {//检查是否是依赖文件
            const suffix = path.substr(path.lastIndexOf(".") + 1);
            return this.webpack.dependenciesList.has(path)
        }

        //todo 热更新update事件   发现文件变化执行热更新 (重新生成bundle代码 保存到内存 推送给客户端  客户端eval执行)
        this.watcher.on('change', (path) => {
            if (isDep(path)) {
                console.log(path + '改变,更新模块');
                this.updateBundle(path)
            }
        })

        //todo 热更新delete事件  
        this.watcher.on('delete', (path) => {
            if (isDep(path)) {
                console.log(path + '删除,删除模块,重新打包');
            }
        })

        //todo 热更新create事件  
        this.watcher.on('create', (path) => {
            if (!isDep(path)) {
                console.log(path + '创建,新增模块,重新打包后生效');
            }
        })

        this.watcher.watch()
    }

    //! 初始化生成bundle代码
    initBundleCode() {
        this.memoFs.mkdirpSync("/memoStatic");

        const bundleCode = this.webpack.buildModules('serverBundle')
        this.memoFs.writeFileSync(`/memoStatic/bundle.js`, bundleCode);

        const bundleCSS = this.webpack.config.plugins[1].bundleCSS(this.webpack)
        this.memoFs.writeFileSync(`/memoStatic/bundle.css`, bundleCSS);
    }


    //! 更新bundle.js并计算hash  发送给浏览器
    updateBundle(path) {
        const jsCode = this.webpack.createNewBundle([path])
        this.memoFs.writeFileSync(`/memoStatic/bundle.js`, jsCode);
        const bundleCSS = this.webpack.config.plugins[1].bundleCSS(this.webpack)
        this.memoFs.writeFileSync(`/memoStatic/bundle.css`, bundleCSS);

        const jsHash = this.caculateHash('/memoStatic/bundle.js')
        const cssHash = this.caculateHash('/memoStatic/bundle.css')
        const hash = jsHash + '-' + cssHash
        if (this.wsConnection) {
            this.wsConnection.send(hash)
            console.log('本次热更新hash', hash);
        }
    }

    //! 更新bundle.css并计算hash  发送给浏览器
    updateCssBundle(path) {
        const bundleCSS = this.webpack.config.plugins[1].bundleCSS(this.webpack)
        this.memoFs.writeFileSync(`/memoStatic/bundle.css`, bundleCSS);
        const hash = this.caculateHash('/memoStatic/bundle.css')
        if (this.wsConnection) {
            // this.wsConnection.send(hash)
            console.log('本次热更新的CSS hash', hash);
        }
    }

    //TODO 计算文件hash(内存)
    caculateHash(path) {
        const spark = new SparkMD5()
        const buffer = this.memoFs.readFileSync(path);
        spark.append(buffer)
        const hash = spark.end()
        return hash
    }

    run() {
        this.initBundleCode()
        this.startServer()
        this.connectWebSocket()
        this.watchFiles()
    }
}


module.exports = WebpackDevServer


//! devServer流程
// 访问8080  发送index.html到页面  通过script和link标签发请求获取js和css代码
// 同时开启websocket 发送初始hash保存到浏览器
// 后端监听文件变更 重新bundle  计算hash 发送新hash到浏览器
// 浏览器判断hash是否相同  不相同重新刷新页面  随之页面发请求获取bundle